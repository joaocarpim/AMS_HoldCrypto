==== C:\dev\AMS_HoldCrypto\frontend\src\app\(app)\currency\page.tsx ====
import CurrencyPage from '@/features/currency/pages/MarketsPage';

// CORREÇÃO: Este arquivo agora importa e renderiza o CurrencyPage, e não mais o Dashboard.
export default CurrencyPage;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\(app)\dashboard\page.tsx ====
import DashboardPage from '@/features/dashboard/pages/DashboardPage';

// Este arquivo garante que a rota /dashboard renderize o componente DashboardPage.
export default DashboardPage;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\(app)\layout.tsx ====
import { AppLayout } from "@/shared/components/AppLayout";
import Footer from "@/shared/components/Footer"; // 1. Importe o Footer
import { Box } from "@mui/material";

// Este arquivo aplica o layout com o menu lateral e o rodapé a todas as páginas filhas.
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      <AppLayout>
        {children}
      </AppLayout>
      {/* 2. Adicione o Footer aqui, fora do AppLayout para que ele fique no final da página */}
      <Footer />
    </Box>
  );
}


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\(app)\users\page.tsx ====
import ListUsersPage from "@/features/user/pages/UserPage";
export default ListUsersPage;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\components\Footer.tsx ====
import React from "react";

const Footer = () => {
  return (
    <footer className="bg-black w-full p-6 text-center text-sm text-yellow-500">
      <p>&copy; {new Date().getFullYear()} AMS Trade Holding. Todos os direitos reservados.</p>
    </footer>
  );
};

export default Footer;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\components\Header.tsx ====
'use client';

import React, { useEffect, useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import axios from 'axios';

export default function Header() {
  const router = useRouter();
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [userName, setUserName] = useState('');

  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      axios
        .get('/api/auth/profile', {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })
        .then((res) => {
          setIsLoggedIn(true);
          setUserName(res.data.user); // ajuste conforme a resposta real
        })
        .catch((err) => {
          console.error('Erro ao buscar perfil:', err);
          setIsLoggedIn(false);
        });
    }
  }, []);

  const handleLogout = () => {
    localStorage.removeItem('token');
    setIsLoggedIn(false);
    setUserName('');
    router.push('/login');
  };

  return (
    <header className="bg-black text-yellow-400 shadow-md sticky top-0 z-50">
      <div className="max-w-7xl mx-auto flex items-center justify-between py-4 px-6 md:px-8">
        <Link href="/">
          <h1 className="text-4xl font-bold uppercase tracking-wide hover:text-yellow-500 transition duration-300 cursor-pointer">
            AMS HoldCrypto
          </h1>
        </Link>

        <nav className="flex items-center space-x-6">
          {isLoggedIn ? (
            <>
              <span className="text-lg font-semibold text-yellow-400">
                Olá, {userName}
              </span>
              <button
                onClick={handleLogout}
                className="px-6 py-2 bg-red-600 text-white font-medium rounded-lg shadow hover:bg-red-700 transition duration-300"
              >
                Sair
              </button>
            </>
          ) : (
            <>
              <Link href="/login">
                <button className="px-6 py-2 bg-yellow-400 text-black font-medium rounded-lg shadow hover:bg-yellow-500 transition duration-300">
                  Login
                </button>
              </Link>
              <Link href="/register">
                <button className="px-6 py-2 bg-yellow-400 text-black font-medium rounded-lg shadow hover:bg-yellow-500 transition duration-300">
                  Registrar-se
                </button>
              </Link>
            </>
          )}
        </nav>
      </div>
    </header>
  );
}


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\components\UserForm.tsx ====
"use client";

import React, { useState } from "react";
import { UserFormValues } from "@/app/types/UserFormValues";

interface UserFormProps {
  initialValues?: UserFormValues; //Para edição ou valores iniciais
  onSubmit: (values: UserFormValues) => void;
  buttonLabel?: string;
}

const UserForm: React.FC<UserFormProps> = ({
  initialValues,
  onSubmit,
  buttonLabel,
}) => {
  const [values, setValues] = useState<UserFormValues>(
    initialValues || {
      name: "",
      email: "",
      phone: "",
      address: "",
      password: "",
      photo: "",
    }
  );

  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues({ ...values, [name]: value });
    setErrors({ ...errors, [name]: "" });
  };

  const validateForm = (): boolean => {
    const newErrors: { [key: string]: string } = {};

    if (!values.name) newErrors.name = "O nome é obrigatório.";
    if (!values.email) {
      newErrors.email = "O email é obrigatório.";
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      newErrors.email = "Formato de email inválido.";
    }
    if (!values.phone) newErrors.phone = "O telefone é obrigatório.";
    if (!values.password) newErrors.password = "A senha é obrigatória.";

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (validateForm()) {
      onSubmit(values);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {[
        { label: "Nome", id: "name", type: "text", placeholder: "Seu nome" },
        {
          label: "Email",
          id: "email",
          type: "email",
          placeholder: "Seu email",
        },
        {
          label: "Telefone",
          id: "phone",
          type: "text",
          placeholder: "Seu telefone",
        },
        {
          label: "Endereço",
          id: "address",
          type: "text",
          placeholder: "Seu endereço",
        },
        {
          label: "Senha",
          id: "password",
          type: "password",
          placeholder: "Sua senha",
        },
        {
          label: "Foto (URL)",
          id: "photo",
          type: "text",
          placeholder: "URL da sua foto",
        },
      ].map(({ label, id, type, placeholder }) => (
        <div key={id}>
          <label
            htmlFor={id}
            className="block text-sm font-medium text-gray-700"
          >
            {label}
          </label>
          <input
            type={type}
            name={id}
            id={id}
            value={values[id as keyof UserFormValues] as string}
            onChange={handleChange}
            placeholder={placeholder}
            className="mt-1 block w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-yellow-400 focus:outline-none text-black"
          />
          {errors[id] && (
            <p className="text-red-500 text-sm mt-1">{errors[id]}</p>
          )}
        </div>
      ))}
      <button
        type="submit"
        className="w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-3 rounded-lg transition duration-300"
      >
        {buttonLabel || "Registrar"}
      </button>
    </form>
  );
};

export default UserForm;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\favicon.ico ====
-- BEGIN BASE64 ENCODED BINARY --
AAABAAQAEBAAAAEAIAAoBQAARgAAACAgAAABACAAKBQAAG4FAAAwMAAAAQAgACgtAACWGQAAAAAAAAEAIACNHgAAvkYAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAABdAAAAugAAALoAAABdAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAKAAAADyAAAA/wAAAP8AAAD/AAAA/wAAAPIAAACgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAOAAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOAAAAA4AAAAAAAAAAAAAAAAAAAAHwAAAOIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4gAAAB8AAAAAAAAAAAAAAKEAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAChAAAAAAAAACMAAAD0AAAA/wAAAP9PT0//rq6u/6urq/+rq6v/q6ur/6urq/+tra3/Z2dn/wAAAP8AAAD/AAAA9AAAACMAAABZAAAA/wAAAP8AAAD/Hx8f/+3t7f///////////////////////f39/zU1Nf8AAAD/AAAA/wAAAP8AAABZAAAAuwAAAP8AAAD/AAAA/wAAAP9ra2v//////////////////////46Ojv8AAAD/AAAA/wAAAP8AAAD/AAAAuwAAALsAAAD/AAAA/wAAAP8AAAD/CQkJ/83Nzf///////////+Tk5P8YGBj/AAAA/wAAAP8AAAD/AAAA/wAAALsAAABZAAAA/wAAAP8AAAD/AAAA/wAAAP9KSkr//f39//////9ra2v/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAABZAAAAIwAAAPQAAAD/AAAA/wAAAP8AAAD/AQEB/7a2tv/V1dX/CQkJ/wAAAP8AAAD/AAAA/wAAAP8AAAD0AAAAIwAAAAAAAAChAAAA/wAAAP8AAAD/AAAA/wAAAP8xMTH/RERE/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAoQAAAAAAAAAAAAAAHwAAAOIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4gAAAB8AAAAAAAAAAAAAAAAAAAA4AAAA4AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA4AAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAACgAAAA8gAAAP8AAAD/AAAA/wAAAP8AAADyAAAAoAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAABdAAAAugAAALoAAABdAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAsAAAAVQAAAIEAAADoAAAA6AAAAIEAAABVAAAALAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACoAAACFAAAA0gAAAPkAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD5AAAA0gAAAIUAAAAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAACWAAAA8wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPMAAACWAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRAAAA4QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADhAAAAUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcgAAAPsAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD7AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPAAAA+wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD7AAAATwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGwAAAOQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADjAAAAGwAAAAAAAAAAAAAAAAAAAAAAAACXAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACXAAAAAAAAAAAAAAAAAAAAKAAAAPUAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPQAAAAnAAAAAAAAAAAAAACGAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/ODg4/4uLi/+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+IiIj/iIiI/4iIiP+JiYn/X19f/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIYAAAAAAAAABwAAANQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8eHh7/7u7u//////////////////////////////////////////////////////////////////////9TU1P/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA1AAAAAcAAAArAAAA+gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9oaGj/////////////////////////////////////////////////////////////////rq6u/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD6AAAAKwAAAFQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wgICP/Ly8v///////////////////////////////////////////////////////T09P8sLCz/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAABUAAAAggAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0dHR//9/f3/////////////////////////////////////////////////jY2N/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIEAAADpAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/62trf///////////////////////////////////////////+Tk5P8XFxf/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA6QAAAOkAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/Kysr//Pz8///////////////////////////////////////ampq/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADpAAAAgQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/i4uL/////////////////////////////////8zMzP8ICAj/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIIAAABUAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8WFhb/4+Pj///////////////////////9/f3/SUlJ/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAVAAAACsAAAD6AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9oaGj//////////////////////6+vr/8BAQH/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPoAAAArAAAABwAAANQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wgICP/Ly8v////////////09PT/LCws/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA1AAAAAcAAAAAAAAAhgAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0dHR//9/f3//////42Njf8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACGAAAAAAAAAAAAAAAnAAAA9AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/7Gxsf/s7Oz/FxcX/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA9QAAACgAAAAAAAAAAAAAAAAAAACXAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/MzMz/19fX/8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACXAAAAAAAAAAAAAAAAAAAAAAAAABoAAADjAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA5AAAABsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE8AAAD7AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPsAAABPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHIAAAD7AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+wAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFEAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAABRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAACWAAAA8wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPMAAACWAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAAAhQAAANIAAAD5AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+QAAANIAAACFAAAAKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAACwAAABVAAAAgQAAAOgAAADoAAAAgQAAAFUAAAAsAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAwAAAAYAAAAAEAIAAAAAAAAC0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAKAAAAEwAAABqAAAAswAAAPgAAAD3AAAAswAAAGoAAABLAAAAKAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAVgAAAKAAAADYAAAA+AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAANgAAACgAAAAVQAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAIsAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAACLAAAAJgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAACLAAAA7wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA7wAAAIsAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUQAAANwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADcAAAAUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACKAAAA/gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/gAAAIoAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAK0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACtAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAuAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAuAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACuAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAK4AAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAP0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD9AAAATwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA3wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAIsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACMAAADxAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPEAAAAjAAAAAAAAAAAAAAAAAAAAAAAAAIwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACLAAAAAAAAAAAAAAAAAAAAEQAAAOQAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8kJCT/aGho/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/2VlZf9lZWX/ZWVl/1BQUP8BAQH/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADkAAAAEQAAAAAAAAAAAAAAVQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8cHBz/6+vr/////////////////////////////////////////////////////////////////////////////////////////////////////////////////3Nzc/8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAVQAAAAAAAAAAAAAAoQAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/ZWVl////////////////////////////////////////////////////////////////////////////////////////////////////////////zMzM/wgICP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAoQAAAAAAAAAJAAAA2gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/BwcH/8nJyf/////////////////////////////////////////////////////////////////////////////////////////////////9/f3/SEhI/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA2gAAAAkAAAAoAAAA+QAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/0VFRf/8/Pz///////////////////////////////////////////////////////////////////////////////////////////+urq7/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAACgAAABLAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP+qqqr///////////////////////////////////////////////////////////////////////////////////////T09P8sLCz/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAEwAAABqAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8pKSn/8vLy/////////////////////////////////////////////////////////////////////////////////4yMjP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAGoAAAC0AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/iIiI////////////////////////////////////////////////////////////////////////////4+Pj/xYWFv8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAALMAAAD4AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/FBQU/+Hh4f//////////////////////////////////////////////////////////////////////aWlp/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPgAAAD4AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/2VlZf/////////////////////////////////////////////////////////////////Ly8v/CAgI/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAPgAAACzAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wcHB//Jycn///////////////////////////////////////////////////////39/f9ISEj/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAALQAAABqAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP9FRUX//Pz8/////////////////////////////////////////////////66u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AAAAAAAAAAAAAAAAAAAAAAAVAAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA3wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATwAAAP0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD9AAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIoAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACuAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAK4AAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAuAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAAuAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAK0AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAACtAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAACKAAAA/gAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/gAAAIoAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUgAAANwAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADcAAAAUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAACLAAAA7wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA7wAAAIsAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgAAAIsAAADhAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAOEAAACLAAAAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAVQAAAKAAAADYAAAA+AAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA+AAAANgAAACgAAAAVgAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAKAAAAEsAAABqAAAAswAAAPcAAAD4AAAAswAAAGoAAABMAAAAKAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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
-- END BASE64 ENCODED BINARY --

==== C:\dev\AMS_HoldCrypto\frontend\src\app\global.d.ts ====
declare module '*.css';

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\layout.tsx ====
// Caminho: src/app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "@/app/styles/globals.css";
import { ThemeProvider } from "../shared/theme/ThemeProvider";
import { NotificationProvider } from "@/shared/context/NotificationContext";
// 1. Importar o AuthInitializer
import { AuthInitializer } from "@/shared/components/AuthInitializer"; // Ajuste o caminho se necessário

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
    title: "AMS HoldCrypto",
    description: "Sua plataforma completa para o universo cripto.",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="pt-br">
            <body className={inter.className}>
                <ThemeProvider>
                    <NotificationProvider>
                        {/* 2. Envolver {children} com AuthInitializer */}
                        <AuthInitializer>
                            {children}
                        </AuthInitializer>
                    </NotificationProvider>
                </ThemeProvider>
            </body>
        </html>
    );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\login\page.tsx ====

import LoginPage from "@/features/auth/LoginPage";
export default LoginPage;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\page.tsx ====
'use client';
import React, { useState, useEffect } from 'react';
import { Box, Button, Container, Typography, Grid, Paper, CircularProgress } from '@mui/material';
import { useTheme } from '@mui/material/styles';
import Link from 'next/link';
import Header from '@/shared/components/Header';
import Footer from '@/shared/components/Footer';
import NewsSection from '@/shared/components/NewsSection';
import CoinHighlight from '@/shared/components/CoinHighlight'; // Importando o novo componente
import currencyService from '@/features/currency/services/currencyService';
import { Currency } from '@/features/currency/types/Currency';

// --- Seção Hero (Banner Principal) ---
const HeroSection = () => (
  <Box
    sx={{
      position: 'relative',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      minHeight: '80vh',
      textAlign: 'center',
      color: '#fff',
      '&::before': {
        content: '""',
        position: 'absolute',
        top: 0, left: 0, right: 0, bottom: 0,
        backgroundImage: 'url(https://img.freepik.com/fotos-premium/bolsa-de-valores-grafico-de-precos-criptomoeda-em-uma-tela-grafico-de-velas-btc-mercado-de-cambio-online-negociacao-licitacao-rastreando-a-taxa-de-criptomoeda-4-k-fechar-se_130265-9837.jpg)',
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        filter: 'brightness(0.3)',
        zIndex: 1,
      },
      '& > *': {
        zIndex: 2,
      },
    }}
  >
    <Container maxWidth="md">
      <Typography variant="h1" component="h1" fontWeight="bold" gutterBottom>
        HoldCrypto
      </Typography>
      <Typography variant="h5" component="p" color="textSecondary" sx={{ mb: 4, color: '#e0e0e0' }}>
        O futuro das finanças digitais começa agora. Domine o mercado de criptomoedas com ferramentas de ponta.
      </Typography>
      <Link href="/register" passHref>
        <Button variant="contained" color="primary" size="large" sx={{ fontWeight: 'bold', px: 6, py: 2, fontSize: '1.2rem' }}>
          Comece Agora
        </Button>
      </Link>
    </Container>
  </Box>
);

// --- NOVA Seção de Destaques do Mercado ---
const CoinHighlightsSection = () => {
    const [currencies, setCurrencies] = useState<Currency[]>([]);
    const [loading, setLoading] = useState(true);
    const theme = useTheme();

    useEffect(() => {
        const fetchCurrencies = async () => {
            try {
                // Busca as moedas do nosso backend
                const data = await currencyService.getAll();
                setCurrencies(data);
            } catch (error) {
                console.error("Erro ao buscar moedas para destaques:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchCurrencies();
    }, []);

    const getChange = (histories: Currency['histories']) => {
        if (!histories || histories.length < 2) return 0;
        const sorted = [...histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime());
        const latestPrice = sorted[0].price;
        const previousPrice = sorted[1].price;
        if (previousPrice === 0) return 0;
        return ((latestPrice - previousPrice) / previousPrice) * 100;
    };

    return (
        <Box sx={{ py: 10, bgcolor: '#0B0B0B' }}>
            <Container maxWidth="lg">
                <Typography variant="h3" textAlign="center" fontWeight="bold" sx={{ color: '#fff', mb: 8 }}>
                    Destaques do <span style={{ color: theme.palette.primary.main }}>Mercado</span>
                </Typography>
                {loading ? (
                    <Box display="flex" justifyContent="center"><CircularProgress color="primary"/></Box>
                ) : (
                    <Grid container spacing={4}>
                        {currencies.slice(0, 6).map((coin) => (
                            <Grid item xs={12} sm={6} md={4} key={coin.id}>
                                <CoinHighlight 
                                    name={coin.name}
                                    symbol={coin.symbol}
                                    price={coin.histories?.[0]?.price || 0}
                                    change={getChange(coin.histories)}
                                />
                            </Grid>
                        ))}
                    </Grid>
                )}
            </Container>
        </Box>
    );
}


// --- Página Principal ---
export default function HomePage() {
  const theme = useTheme();
  return (
    <Box sx={{ bgcolor: '#0B0B0B' }}>
      <Header />
      <main>
        <HeroSection />
        <CoinHighlightsSection />
        <NewsSection />
      </main>
      <Footer />
    </Box>
  );
}



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\register\page.tsx ====
import RegisterPage from "@/features/auth/RegisterPage";
export default RegisterPage;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\styles\globals.css ====
@tailwind base;
@tailwind components;
@tailwind utilities;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\app\types\UserFormValues.ts ====
export interface UserFormValues {
    name: string;
    email: string;
    phone: string;
    address: string;
    password: string;
    photo: string;
  }

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\auth\LoginPage.tsx ====
// Caminho: frontend/src/features/auth/LoginPage.tsx

"use client";

import { useState, useEffect } from "react"; // Adicionado useEffect
import { useRouter } from "next/navigation";
import Container from "@mui/material/Container";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import IconButton from "@mui/material/IconButton";
import InputAdornment from "@mui/material/InputAdornment";
import CircularProgress from "@mui/material/CircularProgress";
import Stack from "@mui/material/Stack";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";
import Header from "@/shared/components/Header";
import Footer from "@/shared/components/Footer";
import { authFormBox } from "@/shared/theme/boxStyles";
import { yellowField } from "@/shared/theme/fieldStyles";
import Link from "next/link";

// 1. Importar os hooks do store em vez do authService diretamente
import { useAuthActions, useAuthLoading, useAuthError, useIsAuthenticated } from './store/useAuthStore'; // Ajuste o caminho

export default function LoginPage() {
    const router = useRouter();
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [showPassword, setShowPassword] = useState(false);

    // 2. Usar o estado e ações do store
    const { login } = useAuthActions();
    const isLoading = useAuthLoading(); // Pega o estado de loading do store
    const authError = useAuthError();    // Pega o estado de erro do store
    const isAuthenticated = useIsAuthenticated(); // Pega o status de autenticação

    // 3. Redirecionar se já estiver autenticado
    useEffect(() => {
        if (isAuthenticated) {
            console.log("LoginPage: Already authenticated, redirecting to dashboard...");
            router.push('/dashboard'); // Redireciona para o dashboard se já logado
        }
    }, [isAuthenticated, router]);


    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        // 4. Chamar a ação de login do store
        const success = await login(email, password);

        // 5. Redirecionar APENAS se o login for bem-sucedido
        // O store já trata de salvar o token e buscar o perfil
        if (success) {
            console.log("Login successful, redirecting to dashboard...");
            router.push("/dashboard"); // Redireciona para o dashboard principal
        } else {
            console.log("Login failed, error should be displayed.");
            // O erro já foi setado no store e será exibido pelo hook useAuthError
        }
    };

     // Se já autenticado, pode retornar null ou um loader enquanto redireciona
     if (isAuthenticated) {
        return (
             <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', bgcolor: '#0B0B0B' }}>
                 <CircularProgress color="primary" />
                 <Typography sx={{ ml: 2, color: 'primary.main' }}>Redirecionando...</Typography>
             </Box>
        );
     }


    return (
        <>
            <Header />
            <Container maxWidth="sm" sx={{ minHeight: "80vh", display: "flex", alignItems: "center" }}>
                <Box component="form" onSubmit={handleLogin} sx={authFormBox}>
                    <Typography variant="h4" fontWeight="bold" color="primary" textAlign="center" mb={4}>
                        Faça seu Login
                    </Typography>
                    <Stack spacing={3}>
                        <TextField
                            label="Email"
                            type="email"
                            value={email}
                            onChange={e => setEmail(e.target.value)}
                            fullWidth
                            required
                            disabled={isLoading} // Usa isLoading do store
                            variant="outlined"
                            autoComplete="email"
                            sx={yellowField}
                        />
                        <TextField
                            label="Senha"
                            type={showPassword ? "text" : "password"}
                            value={password}
                            onChange={e => setPassword(e.target.value)}
                            fullWidth
                            required
                            disabled={isLoading} // Usa isLoading do store
                            variant="outlined"
                            autoComplete="current-password"
                            sx={yellowField}
                            InputProps={{
                                endAdornment: (
                                    <InputAdornment position="end">
                                        <IconButton
                                            aria-label={showPassword ? "Ocultar senha" : "Mostrar senha"}
                                            onClick={() => setShowPassword(v => !v)}
                                            edge="end"
                                            sx={{ color: "#fcd34d" }}
                                            disabled={isLoading} // Usa isLoading do store
                                        >
                                            {showPassword ? <VisibilityOff /> : <Visibility />}
                                        </IconButton>
                                    </InputAdornment>
                                ),
                            }}
                        />
                        {/* 6. Exibe o erro do store */}
                        {authError && (
                            <Typography color="error" textAlign="center" fontWeight="bold">
                                {authError}
                            </Typography>
                        )}
                        <Button
                            type="submit"
                            variant="contained"
                            fullWidth
                            sx={{
                                bgcolor: "#fcd34d",
                                color: "#18181b",
                                fontWeight: "bold",
                                fontSize: "1.1rem",
                                borderRadius: 2,
                                boxShadow: 3,
                                "&:hover": { bgcolor: "#ffe066" },
                                py: 1.5,
                            }}
                            disabled={isLoading} // Usa isLoading do store
                        >
                            {/* 7. Usa isLoading do store */}
                            {isLoading ? <CircularProgress size={24} color="inherit" /> : "Entrar"}
                        </Button>
                        <Typography textAlign="center" mt={2}>
                            Não tem uma conta?{" "}
                            <Link href="/register" style={{ color: "#fcd34d", fontWeight: "bold", textDecoration: "underline" }}>
                                Cadastre-se
                            </Link>
                        </Typography>
                    </Stack>
                </Box>
            </Container>
            <Footer />
        </>
    );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\auth\RegisterPage.tsx ====
"use client";

import { useState, ChangeEvent } from "react";
import { useRouter } from "next/navigation";
import Container from "@mui/material/Container";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import CircularProgress from "@mui/material/CircularProgress";
import Stack from "@mui/material/Stack";
import Alert from "@mui/material/Alert";
import IconButton from "@mui/material/IconButton";
import InputAdornment from "@mui/material/InputAdornment";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";
import Header from "@/shared/components/Header";
import Footer from "@/shared/components/Footer";
import { authFormBox } from "@/shared/theme/boxStyles";
import { yellowField } from "@/shared/theme/fieldStyles";
// CORREÇÃO FINAL: Usando uma importação nomeada com chaves { }
import { userService } from "@/features/user/services/userService";

export default function RegisterPage() {
  const router = useRouter();
  const [form, setForm] = useState({
    name: "",
    email: "",
    phone: "",
    address: "",
    password: "",
    photo: "",
  });
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState("");
  const [error, setError] = useState("");

  const handlePhotoChange = async (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onloadend = () => {
      setForm((prev) => ({ ...prev, photo: reader.result as string }));
    };
    reader.readAsDataURL(file);
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setForm({ ...form, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setSuccess("");
    setLoading(true);
    try {
      // Agora a chamada funciona corretamente
      await userService.create(form);
      setSuccess("Usuário registrado com sucesso!");
      setForm({
        name: "",
        email: "",
        phone: "",
        address: "",
        password: "",
        photo: "",
      });
      setTimeout(() => router.push("/login"), 2000);
    } catch (err: any) {
      setError(err.response?.data?.message || "Erro ao registrar usuário.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <>
      <Header />
      <Container maxWidth="sm" sx={{ minHeight: "80vh", display: "flex", alignItems: "center" }}>
        <Box component="form" onSubmit={handleSubmit} sx={authFormBox}>
          <Typography variant="h4" fontWeight="bold" color="primary" textAlign="center" mb={4}>
            Registrar Usuário
          </Typography>
          <Stack spacing={3}>
            {success && (
              <Alert severity="success" sx={{ fontWeight: "bold", textAlign: "center" }}>
                {success}
              </Alert>
            )}
            {error && (
              <Alert severity="error" sx={{ fontWeight: "bold", textAlign: "center" }}>
                {error}
              </Alert>
            )}
            <TextField label="Nome" name="name" value={form.name} onChange={handleChange} fullWidth required disabled={loading} variant="outlined" sx={yellowField} />
            <TextField label="Email" name="email" type="email" value={form.email} onChange={handleChange} fullWidth required disabled={loading} variant="outlined" sx={yellowField} />
            <TextField label="Telefone" name="phone" value={form.phone} onChange={handleChange} fullWidth required disabled={loading} variant="outlined" sx={yellowField} />
            <TextField label="Endereço" name="address" value={form.address} onChange={handleChange} fullWidth required disabled={loading} variant="outlined" sx={yellowField} />
            <TextField
              label="Senha"
              name="password"
              type={showPassword ? "text" : "password"}
              value={form.password}
              onChange={handleChange}
              fullWidth
              required
              disabled={loading}
              variant="outlined"
              sx={yellowField}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label={showPassword ? "Ocultar senha" : "Mostrar senha"}
                      onClick={() => setShowPassword(v => !v)}
                      edge="end"
                      sx={{ color: "#fcd34d" }}
                      disabled={loading}
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <Button
              variant="outlined"
              component="label"
              sx={{
                borderColor: "#fcd34d",
                color: "#fcd34d",
                fontWeight: "bold",
                borderRadius: 2,
                "&:hover": { borderColor: "#ffe066", color: "#ffe066" },
              }}
              disabled={loading}
            >
              {form.photo ? "Foto selecionada" : "Enviar Foto"}
              <input
                type="file"
                name="photo"
                accept="image/*"
                hidden
                onChange={handlePhotoChange}
                disabled={loading}
              />
            </Button>
            <Button
              type="submit"
              variant="contained"
              fullWidth
              sx={{
                bgcolor: "#fcd34d",
                color: "#18181b",
                fontWeight: "bold",
                fontSize: "1.1rem",
                borderRadius: 2,
                boxShadow: 3,
                "&:hover": { bgcolor: "#ffe066" },
                py: 1.5,
              }}
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} color="inherit" /> : "Registrar"}
            </Button>
          </Stack>
        </Box>
      </Container>
      <Footer />
    </>
  );
}


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\auth\services\AuthServices.ts ====
// Caminho: frontend/src/features/auth/services/AuthServices.ts

import apiClient from "@/shared/api/apiClient";
import { authAPI } from "@/shared/api/api";

// Interface para a resposta do login (continua igual)
interface LoginResponse {
  token: string;
}

// Interface para o perfil do usuário (AGORA INCLUI O ID)
interface UserProfile {
  id: number;     // <-- NOVO CAMPO: ID numérico do usuário
  user: string;   // Nome do usuário (campo 'user' na resposta)
  email: string;  // Email do usuário
}

const authService = {
  login: async (email: string, password: string): Promise<LoginResponse> => {
    const response = await apiClient.post(authAPI.login(), { email, password });
    return response.data; // Retorna apenas { token: "..." }
  },

  // Ajustado para esperar e retornar a nova interface UserProfile
  getProfile: async (): Promise<UserProfile> => {
    const response = await apiClient.get(authAPI.getProfile());
    // Espera uma resposta como { id: 1, user: "Nome", email: "..." }
    return response.data;
  },
};

export default authService;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\auth\store\useAuthStore.ts ====
// Caminho: frontend/src/features/auth/store/useAuthStore.ts

import { create } from 'zustand';
import authService from '../services/AuthServices'; // Ajuste o caminho se necessário

// Interface para os dados do perfil que o store vai guardar
interface AuthUser {
  id: number | null;
  name: string | null;
  email: string | null;
}

// Interface completa do estado e das ações do store
interface AuthState {
  token: string | null;
  user: AuthUser;
  isAuthenticated: boolean;
  isLoading: boolean; // Para indicar carregamento inicial do perfil
  error: string | null;
  actions: {
    fetchProfile: () => Promise<void>;
    login: (email: string, password: string) => Promise<boolean>; // Retorna true em sucesso
    logout: () => void;
    setToken: (token: string | null) => void; // Ação auxiliar para setar token externamente se necessário
  };
}

// Estado inicial do store
const initialState = {
  token: null,
  user: { id: null, name: null, email: null },
  isAuthenticated: false,
  isLoading: true, // Começa como true para verificar o token inicial
  error: null,
};

export const useAuthStore = create<AuthState>((set, get) => ({
  ...initialState,
  actions: {
    // Ação para buscar o perfil usando um token existente (ex: no carregamento da página)
    fetchProfile: async () => {
      const currentToken = get().token || (typeof window !== 'undefined' ? localStorage.getItem('token') : null);
      if (!currentToken) {
        console.log("No token found, user is not authenticated.");
        set({ ...initialState, isLoading: false }); // Reset state, finish loading
        return;
      }

      console.log("Token found, attempting to fetch profile...");
      set({ isLoading: true, error: null }); // Start loading
      try {
        // Usa o apiClient configurado que já adiciona o token
        const profile = await authService.getProfile();
        console.log("Profile fetched successfully:", profile);
        set({
          token: currentToken, // Mantém o token
          user: { id: profile.id, name: profile.user, email: profile.email },
          isAuthenticated: true,
          isLoading: false,
          error: null,
        });
      } catch (error: any) {
        console.error("Failed to fetch profile:", error);
        // Se der erro ao buscar perfil (token inválido/expirado), faz logout
        get().actions.logout(); // Chama a ação de logout definida abaixo
        set({
          isLoading: false,
          error: "Sessão inválida ou expirada. Faça login novamente.",
        });
      }
    },

    // Ação para realizar o login
    login: async (email, password) => {
      set({ isLoading: true, error: null });
      try {
        const response = await authService.login(email, password);
        const token = response.token;
        if (typeof window !== 'undefined') {
          localStorage.setItem('token', token); // Salva o token no localStorage
        }
        set({ token: token }); // Atualiza o token no store
        await get().actions.fetchProfile(); // Busca o perfil após login
        return get().isAuthenticated; // Retorna true se fetchProfile foi bem sucedido
      } catch (error: any) {
        console.error("Login failed:", error);
        const errorMessage = error.response?.data?.message || "Erro desconhecido durante o login.";
        set({ isLoading: false, error: errorMessage });
        return false;
      }
    },

    // Ação para fazer logout
    logout: () => {
      console.log("Logging out...");
      if (typeof window !== 'undefined') {
        localStorage.removeItem('token'); // Remove o token do localStorage
      }
      set({ ...initialState, isLoading: false }); // Reseta o estado para o inicial, termina loading
      console.log("User logged out, state reset.");
    },

    // Ação auxiliar para definir o token (pode ser útil em alguns cenários)
    setToken: (token) => {
       set({ token });
       if (token && typeof window !== 'undefined') {
           localStorage.setItem('token', token);
       } else if (!token && typeof window !== 'undefined') {
           localStorage.removeItem('token');
       }
    }
  },
}));

// Hooks de conveniência para acessar o estado e as ações separadamente
export const useAuthUser = () => useAuthStore((state) => state.user);
export const useIsAuthenticated = () => useAuthStore((state) => state.isAuthenticated);
export const useAuthLoading = () => useAuthStore((state) => state.isLoading);
export const useAuthError = () => useAuthStore((state) => state.error);
export const useAuthActions = () => useAuthStore((state) => state.actions);

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\components\CurrencyForm.tsx ====
import React, { useState, useEffect } from "react";
import { Currency, Backing } from "../types/Currency";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import MenuItem from "@mui/material/MenuItem";
import Checkbox from "@mui/material/Checkbox";
import FormControlLabel from "@mui/material/FormControlLabel";
import Stack from "@mui/material/Stack";
import Box from "@mui/material/Box";
import MonetizationOnIcon from "@mui/icons-material/MonetizationOn";
import CurrencyBitcoinIcon from "@mui/icons-material/CurrencyBitcoin";
import EuroIcon from "@mui/icons-material/Euro";
import AttachMoneyIcon from "@mui/icons-material/AttachMoney";
import CurrencyYenIcon from "@mui/icons-material/CurrencyYen";
import CurrencyExchangeIcon from "@mui/icons-material/CurrencyExchange";
import { yellowField } from "@/shared/theme/fieldStyles";

interface Props {
  initialValues: Currency;
  onSubmit: (currency: Currency) => void;
  loading?: boolean;
  onCancel?: () => void;
}

const backings: Backing[] = ["BRL", "USD", "JPY", "EUR", "CNY", "ARS"];

const iconOptions = [
  { label: "Padrão", value: "MonetizationOn" },
  { label: "Bitcoin", value: "CurrencyBitcoin" },
  { label: "Dólar", value: "AttachMoney" },
  { label: "Euro", value: "Euro" },
  { label: "Iene", value: "CurrencyYen" },
  { label: "Exchange", value: "CurrencyExchange" },
];

const iconMap: Record<string, JSX.Element> = {
  MonetizationOn: <MonetizationOnIcon />,
  CurrencyBitcoin: <CurrencyBitcoinIcon />,
  AttachMoney: <AttachMoneyIcon />,
  Euro: <EuroIcon />,
  CurrencyYen: <CurrencyYenIcon />,
  CurrencyExchange: <CurrencyExchangeIcon />,
};

const defaultForm: Currency = {
  name: "",
  symbol: "",
  description: "",
  status: true,
  backing: "USD",
  icon: "MonetizationOn",
};

const CurrencyForm: React.FC<Props> = ({ initialValues, onSubmit, loading, onCancel }) => {
  const safeInitialValues = { ...defaultForm, ...initialValues, icon: initialValues.icon || "MonetizationOn" };
  const [form, setForm] = useState<Currency>(safeInitialValues);

  useEffect(() => {
    setForm({ ...defaultForm, ...initialValues, icon: initialValues.icon || "MonetizationOn" });
    // eslint-disable-next-line
  }, [initialValues]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    setForm((prev) => ({
      ...prev,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  const handleSelectChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setForm((prev) => ({
      ...prev,
      backing: e.target.value as Backing,
    }));
  };

  const handleIconChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setForm((prev) => ({
      ...prev,
      icon: e.target.value,
    }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!form.icon) {
      alert("Selecione um ícone para a moeda.");
      return;
    }
    if (!form.name || !form.symbol || !form.description) {
      alert("Preencha todos os campos obrigatórios.");
      return;
    }
    if (!/^[A-Z0-9]{3,10}$/.test(form.symbol)) {
      alert("O símbolo deve ser em letras maiúsculas, sem espaços, ex: BTC, ETH, ADA.");
      return;
    }
    onSubmit(form);
  };

  return (
    <Box
      component="form"
      onSubmit={handleSubmit}
      sx={{
        p: { xs: 2, sm: 4 },
        display: "flex",
        flexDirection: "column",
        gap: 2,
        bgcolor: "#23272f",
        borderRadius: 3,
        boxShadow: 3,
        maxWidth: 500,
        mx: "auto",
      }}
    >
      <Stack spacing={2}>
        <TextField
          name="name"
          label="Nome"
          value={form.name}
          onChange={handleChange}
          required
          fullWidth
          sx={yellowField}
        />
        <TextField
          name="symbol"
          label="Símbolo (ex: BTC, ETH, ADA)"
          value={form.symbol}
          onChange={handleChange}
          required
          fullWidth
          sx={yellowField}
          inputProps={{ style: { textTransform: "uppercase" }, maxLength: 10 }}
        />
        <TextField
          name="description"
          label="Descrição"
          value={form.description}
          onChange={handleChange}
          required
          fullWidth
          sx={yellowField}
        />
        <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
          <TextField
            select
            name="backing"
            label="Backing"
            value={form.backing}
            onChange={handleSelectChange}
            required
            fullWidth
            sx={yellowField}
          >
            {backings.map((b) => (
              <MenuItem key={b} value={b}>{b}</MenuItem>
            ))}
          </TextField>
          <TextField
            select
            name="icon"
            label="Ícone"
            value={form.icon || "MonetizationOn"}
            onChange={handleIconChange}
            required
            fullWidth
            sx={yellowField}
          >
            {iconOptions.map((opt) => (
              <MenuItem key={opt.value} value={opt.value}>
                <Stack direction="row" alignItems="center" spacing={1}>
                  {iconMap[opt.value]}
                  <span>{opt.label}</span>
                </Stack>
              </MenuItem>
            ))}
          </TextField>
        </Stack>
        <FormControlLabel
          control={
            <Checkbox
              checked={!!form.status}
              onChange={handleChange}
              name="status"
              sx={{
                color: "#fcd34d",
                "&.Mui-checked": { color: "#fcd34d" },
              }}
            />
          }
          label="Ativo"
          sx={{ color: "#fff" }}
        />
        <Stack direction="row" spacing={2} justifyContent="flex-end">
          <Button
            type="submit"
            variant="contained"
            color="primary"
            disabled={loading}
            sx={{ minWidth: 120, fontWeight: "bold" }}
          >
            {loading ? "Salvando..." : "Salvar"}
          </Button>
          {onCancel && (
            <Button
              type="button"
              variant="outlined"
              color="inherit"
              onClick={onCancel}
              disabled={loading}
              sx={{
                minWidth: 120,
                fontWeight: "bold",
                borderColor: "#fcd34d",
                color: "#fcd34d"
              }}
            >
              Cancelar
            </Button>
          )}
        </Stack>
      </Stack>
    </Box>
  );
};

export default CurrencyForm;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\components\MarketsTable.tsx ====
// Caminho: frontend/src/features/currency/components/MarketsTable.tsx
"use client";

import React from 'react';
import { useRouter } from 'next/navigation';
import { Currency, History } from '../types/Currency';
import { useMarketsStore } from '../store/marketsStore';
import { Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Box, Typography, IconButton, Tooltip, Avatar } from '@mui/material';
import { Star, ArrowUp, ArrowDown } from 'lucide-react';

interface MarketsTableProps {
  currencies: Currency[];
}

// Helper para calcular a variação em 24h
const getChange = (histories: History[] | undefined) => {
    if (!histories || histories.length < 2) return 0;
    const sorted = [...histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime());
    const latestPrice = sorted[0].price;
    const previousPrice = sorted[1].price;
    if (previousPrice === 0) return 0;
    return ((latestPrice - previousPrice) / previousPrice) * 100;
};

export const MarketsTable: React.FC<MarketsTableProps> = ({ currencies }) => {
  const router = useRouter();
  const { favorites, toggleFavorite } = useMarketsStore();

  const handleRowClick = (symbol: string) => {
    // Futuramente, isso levará para a página de detalhes da moeda
    // router.push(`/price/${symbol.toLowerCase()}`);
    console.log(`Navegar para detalhes de ${symbol}`);
  };

  return (
    <TableContainer>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell sx={{ fontWeight: "bold", color: "#fcd34d", width: '5%' }}></TableCell>
            <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }}>Ativo</TableCell>
            <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }} align="right">Preço</TableCell>
            <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }} align="right">Variação (24h)</TableCell>
            <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }} align="right">Volume (24h)</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {currencies.map((coin) => {
            const isFavorite = favorites.includes(coin.symbol);
            const change = getChange(coin.histories);
            const isPositive = change >= 0;
            const latestPrice = coin.histories?.[0]?.price || 0;

            // Adicionado fallback para caso o ID não exista (segurança)
            const uniqueKey = coin.id ?? coin.symbol;

            return (
              <TableRow
                // ****** AQUI ESTÁ A MUDANÇA ******
                key={uniqueKey} // Alterado de coin.symbol para uniqueKey (que prioriza coin.id)
                // **********************************
                hover
                onClick={() => handleRowClick(coin.symbol)}
                sx={{ cursor: 'pointer', '&:last-child td, &:last-child th': { border: 0 } }}
              >
                <TableCell>
                  <Tooltip title={isFavorite ? "Remover dos Favoritos" : "Adicionar aos Favoritos"}>
                    <IconButton
                      size="small"
                      onClick={(e) => {
                        e.stopPropagation(); // Evita que o clique na estrela acione o clique na linha
                        toggleFavorite(coin.symbol);
                      }}
                    >
                      <Star size={20} fill={isFavorite ? '#fcd34d' : 'none'} color={isFavorite ? '#fcd34d' : 'gray'} />
                    </IconButton>
                  </Tooltip>
                </TableCell>
                <TableCell>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                    <Avatar sx={{ bgcolor: '#333', width: 32, height: 32 }}>{coin.symbol.charAt(0)}</Avatar>
                    <Box>
                      <Typography fontWeight="bold">{coin.name}</Typography>
                      <Typography variant="body2" color="text.secondary">{coin.symbol}</Typography>
                    </Box>
                  </Box>
                </TableCell>
                <TableCell align="right">
                  <Typography fontWeight="medium">{latestPrice.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</Typography>
                </TableCell>
                <TableCell align="right">
                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', color: isPositive ? 'success.main' : 'error.main' }}>
                    {isPositive ? <ArrowUp size={16} /> : <ArrowDown size={16} />}
                    <Typography fontWeight="medium" sx={{ ml: 0.5 }}>{change.toFixed(2)}%</Typography>
                  </Box>
                </TableCell>
                <TableCell align="right">
                  <Typography color="text.secondary">R$ --</Typography> {/* Placeholder para Volume */}
                </TableCell>
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\pages\MarketsPage.tsx ====
"use client";

import React, { useEffect, useState, useMemo } from 'react';
import { useMarketsStore } from '../store/marketsStore';
import { Box, Typography, CircularProgress, Paper, TextField, InputAdornment } from '@mui/material';
import { Search } from 'lucide-react';
import { MarketsTable } from '../components/MarketsTable'; // 1. Importar a MarketsTable

export default function MarketsPage() {
  const { currencies, loading, error, fetchCurrencies } = useMarketsStore();
  const [searchTerm, setSearchTerm] = useState('');

  useEffect(() => {
    fetchCurrencies();
  }, [fetchCurrencies]);

  const filteredCurrencies = useMemo(() => {
    return currencies.filter(coin =>
      coin.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      coin.symbol.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [currencies, searchTerm]);

  return (
    <Box sx={{ p: { xs: 2, md: 4 }, maxWidth: 1200, mx: "auto" }}>
      {/* Header da Página */}
      <Box mb={4}>
        <Typography variant="h4" fontWeight="bold">Explorar Mercados</Typography>
        <Typography color="text.secondary">Veja os preços e dados de mercado em tempo real.</Typography>
      </Box>

      {/* Filtros e Pesquisa */}
      <Paper sx={{ p: 2, mb: 4, bgcolor: '#1E1E1E', borderRadius: 4, display: 'flex', gap: 2, alignItems: 'center' }}>
          <TextField
                variant="outlined"
                fullWidth
                size="small"
                placeholder="Pesquisar por nome ou símbolo..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                InputProps={{
                    startAdornment: (
                        <InputAdornment position="start">
                            <Search size={18} />
                        </InputAdornment>
                    ),
                }}
            />
          {/* Aqui virão os botões de filtro */}
      </Paper>

      {/* Tabela de Moedas */}
      {loading ? (
        <Box display="flex" justifyContent="center" py={10}><CircularProgress color="primary" /></Box>
      ) : error ? (
        <Typography color="error" textAlign="center" py={10}>{error}</Typography>
      ) : (
        <Paper sx={{ bgcolor: '#1E1E1E', borderRadius: 4, overflow: 'hidden' }}>
          {/* 2. Renderizar a MarketsTable, passando as moedas filtradas */}
          <MarketsTable currencies={filteredCurrencies} />
        </Paper>
      )}
    </Box>
  );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\services\currencyService.ts ====
import apiClient from "@/shared/api/apiClient";
import { currencyAPI } from "@/shared/api/api";
import { Currency } from "../types/Currency";

const currencyService = {
  getAll: async (): Promise<Currency[]> => {
    const response = await apiClient.get(currencyAPI.getAll());
    return response.data;
  },

  getById: async (id: number): Promise<Currency> => {
    const response = await apiClient.get(currencyAPI.getById(id));
    return response.data;
  },

  create: async (currency: Omit<Currency, "id" | "histories">): Promise<Currency> => {
    const response = await apiClient.post(currencyAPI.create(), currency);
    return response.data;
  },

  update: async (id: number, currency: Partial<Currency>): Promise<Currency> => {
    const response = await apiClient.put(currencyAPI.update(id), currency);
    return response.data;
  },

  delete: async (id: number): Promise<void> => {
    await apiClient.delete(currencyAPI.delete(id));
  },
};

export default currencyService;



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\store\marketsStore.ts ====
import { create } from 'zustand';
import currencyService from '@/features/currency/services/currencyService';
import { Currency } from '../types/Currency';

// Função para carregar os favoritos do localStorage
const loadFavorites = (): string[] => {
  if (typeof window === 'undefined') return [];
  const favorites = localStorage.getItem('cryptoFavorites');
  return favorites ? JSON.parse(favorites) : [];
};

interface MarketsState {
  currencies: Currency[];
  favorites: string[]; // Armazenaremos os símbolos das moedas favoritas (ex: 'BTC', 'ETH')
  loading: boolean;
  error: string | null;
  fetchCurrencies: () => Promise<void>;
  toggleFavorite: (symbol: string) => void;
}

export const useMarketsStore = create<MarketsState>((set) => ({
  currencies: [],
  favorites: loadFavorites(),
  loading: false,
  error: null,

  fetchCurrencies: async () => {
    set({ loading: true, error: null });
    try {
      // Usando o seu currencyService existente!
      const data = await currencyService.getAll();
      set({ currencies: data, loading: false });
    } catch (error) {
      console.error("Erro ao buscar moedas:", error);
      set({ error: 'Falha ao carregar dados do mercado.', loading: false });
    }
  },

  toggleFavorite: (symbol: string) => {
    set((state) => {
      const newFavorites = state.favorites.includes(symbol)
        ? state.favorites.filter((fav) => fav !== symbol)
        : [...state.favorites, symbol];
      
      localStorage.setItem('cryptoFavorites', JSON.stringify(newFavorites));
      return { favorites: newFavorites };
    });
  },
}));

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\currency\types\Currency.ts ====
export type Backing = "BRL" | "USD" | "JPY" | "EUR" | "CNY" | "ARS";

export interface History {
  id: number;
  datetime: string;
  price: number;
  currencyId: number;
}

export interface Currency {
  id?: number;
  name: string;
  symbol: string; // NOVO CAMPO
  description: string;
  status: boolean;
  backing: Backing;
  icon: string;
  histories?: History[];
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\HotList.tsx ====
// Caminho: frontend/src/features/dashboard/components/HotList.tsx
'use client';
import { Paper, Box, Typography, useTheme, Stack, Avatar } from '@mui/material';
import { useDashboardStore } from '../store/DashboardStore';
import { Currency, History } from '@/features/currency/types/Currency';

// --- ADICIONAR NOVA FUNÇÃO formatCurrencyValue ---
const formatCurrencyValue = (value: number | undefined | null): string => {
    const numericValue = Number(value);
    if (isNaN(numericValue) || value === undefined || value === null) {
        return "R$ --";
    }

    const prefix = "R$ ";
    
    if (numericValue >= 1_000_000_000_000) { // Trilhão (T)
        return prefix + (numericValue / 1_000_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " T";
    }
    if (numericValue >= 1_000_000_000) { // Bilhão (B)
        return prefix + (numericValue / 1_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " B";
    }
    if (numericValue >= 1_000_000) { // Milhão (M)
        return prefix + (numericValue / 1_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " M";
    }
    if (numericValue >= 1_000) { // Mil (K)
        return prefix + (numericValue / 1_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " K";
    }
    
    return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2, maximumFractionDigits: 2 });
};
// ---------------------------------------------

// Função para calcular a variação percentual
const getChange = (histories: History[] | undefined) => {
    // ... (lógica mantida) ...
    if (!histories || histories.length < 2) return 0;
    const sorted = [...histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime());
    const latestPrice = sorted[0].price;
    const previousPrice = sorted[1].price;
    if (previousPrice === 0) return 0;
    return ((latestPrice - previousPrice) / previousPrice) * 100;
};

// Componente para um único item da lista
const HotListItem = ({ coin, isSelected, onSelect }: { coin: Currency, isSelected: boolean, onSelect: () => void }) => {
    const theme = useTheme();
    const change = getChange(coin.histories);
    const isPositive = change >= 0;
    const latestPrice = coin.histories?.[0]?.price || 0;

    return (
        <Box 
            onClick={onSelect}
            sx={{ 
                display: 'flex', 
                justifyContent: 'space-between', 
                alignItems: 'center',
                cursor: 'pointer',
                p: 1.5,
                borderRadius: 3,
                backgroundColor: isSelected ? 'rgba(240, 185, 11, 0.1)' : 'transparent',
                border: `1px solid ${isSelected ? theme.palette.primary.main : 'transparent'}`,
                transition: 'background-color 0.2s, border-color 0.2s',
                '&:hover': {
                    backgroundColor: 'rgba(255, 255, 255, 0.05)'
                }
            }}
        >
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
                <Avatar sx={{ bgcolor: theme.palette.primary.main, width: 36, height: 36, color: '#0B0B0B', fontWeight:'bold', fontSize: '1rem' }}>
                    {coin.symbol.charAt(0)}
                </Avatar>
                <Box>
                    <Typography variant="body1" fontWeight="bold">{coin.symbol}</Typography>
                    <Typography variant="body2" color="text.secondary" sx={{ mt: -0.5 }}>{coin.name}</Typography>
                </Box>
            </Box>
            <Box sx={{ textAlign: 'right' }}>
                {/* *** MUDANÇA AQUI *** */}
                <Typography variant="body1" fontWeight="bold">
                    {formatCurrencyValue(latestPrice)} 
                </Typography>
                {/* ******************* */}
                <Typography variant="body2" fontWeight="bold" sx={{ color: isPositive ? theme.palette.success.main : theme.palette.error.main }}>
                    {isPositive ? '+' : ''}{change.toFixed(2)}%
                </Typography>
            </Box>
        </Box>
    );
};

export const HotList = () => {
    const { currencies, selectedCoin, setSelectedCoin } = useDashboardStore();
    return (
        <Paper sx={{ p: { xs: 2, md: 3 }, bgcolor: '#1E1E1E', borderRadius: 4 }}>
            <Typography variant="h6" fontWeight="bold" gutterBottom>Hot List</Typography>
            <Stack spacing={1} mt={2}>
                {currencies.map((coin) => (
                    <HotListItem 
                         key={coin.id ?? coin.symbol} // Garante key única
                        coin={coin}
                        isSelected={selectedCoin?.id === coin.id}
                        onSelect={() => setSelectedCoin(coin)}
                     />
                ))}
            </Stack>
        </Paper>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\OverviewChart.tsx ====
'use client';
import { Paper, Box, Typography, useTheme } from '@mui/material';
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid } from 'recharts';
import { useDashboardStore } from '../store/DashboardStore';

// Helper para formatar valores grandes no eixo Y do gráfico
const formatChartValue = (value: number) => {
  if (value >= 1000) return `${(value / 1000).toFixed(1)}K`;
  return value.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
};

// Um componente customizado para o Tooltip, para um visual mais refinado
const CustomTooltip = ({ active, payload, label }: any) => {
  const theme = useTheme();
  if (active && payload && payload.length) {
    return (
      <Paper sx={{ p: 1.5, bgcolor: 'rgba(30, 30, 30, 0.9)', borderRadius: 2, border: '1px solid #444' }}>
        <Typography variant="caption" color="text.secondary">{label}</Typography>
        <Typography variant="body2" fontWeight="bold" sx={{ color: theme.palette.primary.main }}>
          {payload[0].value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
        </Typography>
      </Paper>
    );
  }
  return null;
};

export const OverviewChart = () => {
  const theme = useTheme();
  // Conectando ao nosso store para obter a moeda selecionada
  const selectedCoin = useDashboardStore((state) => state.selectedCoin);

  // Transformamos os dados do histórico para o formato que o gráfico espera
  const chartData = selectedCoin?.histories
    ?.map(h => ({
      name: new Date(h.datetime).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),
      price: h.price
    }))
    .reverse(); // Revertemos para ter a ordem cronológica correta

  return (
    <Paper sx={{ p: { xs: 2, md: 3 }, bgcolor: '#1E1E1E', borderRadius: 4, mb: 4 }}>
      <Typography variant="h6" fontWeight="bold" gutterBottom>
        {selectedCoin ? `Histórico de ${selectedCoin.name}` : 'Visão Geral'}
      </Typography>
      <Box sx={{ height: 300, mt: 3 }}>
        <ResponsiveContainer width="100%" height="100%">
          <AreaChart data={chartData} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
            <defs>
              <linearGradient id="colorPrice" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={theme.palette.primary.main} stopOpacity={0.8} />
                <stop offset="95%" stopColor={theme.palette.primary.main} stopOpacity={0} />
              </linearGradient>
            </defs>
            <XAxis dataKey="name" stroke={theme.palette.text.secondary} fontSize={12} tickLine={false} axisLine={false} />
            <YAxis
              stroke={theme.palette.text.secondary}
              fontSize={12}
              tickLine={false}
              axisLine={false}
              domain={['dataMin', 'dataMax']}
              tickFormatter={formatChartValue}
            />
            <CartesianGrid strokeDasharray="3 3" stroke="#2a2a2a" />
            <Tooltip content={<CustomTooltip />} cursor={{ stroke: theme.palette.primary.main, strokeWidth: 1, strokeDasharray: '3 3' }}/>
            <Area type="monotone" dataKey="price" stroke={theme.palette.primary.main} strokeWidth={2} fillOpacity={1} fill="url(#colorPrice)" />
          </AreaChart>
        </ResponsiveContainer>
      </Box>
    </Paper>
  );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\StatCard.tsx ====
'use client';
import { Paper, Box, Typography, useTheme } from '@mui/material';
import { motion } from 'framer-motion';
import { LucideIcon } from 'lucide-react';

interface StatCardProps {
  title: string;
  value: string;
  change?: number;
  Icon: LucideIcon;
}

export const StatCard = ({ title, value, change, Icon }: StatCardProps) => {
  const theme = useTheme();
  const isPositive = change !== undefined && change >= 0;

  return (
    <Paper
      sx={{
        p: 2.5,
        bgcolor: '#1E1E1E',
        borderRadius: 4,
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
      }}
    >
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <Typography variant="body2" color="text.secondary" fontWeight="medium">
          {title}
        </Typography>
        <Icon size={20} color={theme.palette.text.secondary} />
      </Box>

      <Box mt={2}>
        <Typography variant="h5" fontWeight="bold">
          {value}
        </Typography>
        {change !== undefined && (
          <Typography 
            variant="body2" 
            fontWeight="bold"
            sx={{ color: isPositive ? theme.palette.success.main : theme.palette.error.main }}
          >
            {isPositive ? '+' : ''}{change.toFixed(2)}%
          </Typography>
        )}
      </Box>
    </Paper>
  );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\StatsCards.tsx ====
// Caminho: frontend/src/features/dashboard/components/StatsCards.tsx
'use client';
import { Grid, Box, Typography } from '@mui/material';
import { StatCard } from './StatCard';
import { Wallet, TrendingUp, TrendingDown, Award } from 'lucide-react';
import { motion } from 'framer-motion';
import { useDashboardWallets, useDashboardCurrencies } from '../store/DashboardStore';
import { useMemo } from 'react';

// --- NOVA FUNÇÃO formatCurrencyValue ---
const formatCurrencyValue = (value: number | undefined | null): string => {
    const numericValue = Number(value);
    if (isNaN(numericValue) || value === undefined || value === null) {
        return "R$ --";
    }

    const prefix = "R$ ";
    
    // Lógica de Abreviação
    if (numericValue >= 1_000_000_000_000) { // Trilhão (T)
        return prefix + (numericValue / 1_000_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " T";
    }
    if (numericValue >= 1_000_000_000) { // Bilhão (B)
        return prefix + (numericValue / 1_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " B";
    }
    if (numericValue >= 1_000_000) { // Milhão (M)
        return prefix + (numericValue / 1_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " M";
    }
    if (numericValue >= 1_000) { // Mil (K)
        return prefix + (numericValue / 1_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " K";
    }
    
    // Para valores menores, usa a formatação padrão completa
    return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2, maximumFractionDigits: 2 });
};
// ------------------------------------

const formatPercentValue = (value: number | undefined | null): number | undefined => {
    // ... (função mantida) ...
    if (value === undefined || value === null || isNaN(value)) {
        return undefined;
    }
    return value;
};

// --- Variantes de Animação (Mantidas) ---
const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.1 } } };
const itemVariants = { hidden: { y: 20, opacity: 0 }, visible: { y: 0, opacity: 1 } };

export const StatsCards = () => {
    const wallets = useDashboardWallets();
    const currencies = useDashboardCurrencies();

    // Lógica de cálculo (mantida)
    const calculatedStats = useMemo(() => {
        // ... (cálculo do twentyFourHoursAgo) ...
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).getTime();
        const priceDataMap = new Map<string, { now: number, twentyFourHoursAgoPrice: number | null, change: number }>();
        let bestPerformer = { symbol: '---', change: -Infinity };

        for (const currency of currencies) {
            // ... (lógica de ordenação e busca de preço) ...
            if (!currency.histories || currency.histories.length === 0 || !currency.symbol) continue;
            const sortedHistories = [...currency.histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime());
            const priceNow = sortedHistories[0]?.price;
            if (!priceNow) continue;

            let price24hAgo: number | null = null;
            let smallestDiff = Infinity;
            for (const history of sortedHistories) {
                const historyTime = new Date(history.datetime).getTime();
                if (historyTime <= twentyFourHoursAgo) {
                    const diff = twentyFourHoursAgo - historyTime;
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        price24hAgo = history.price;
                    } else {
                        break; 
                    }
                }
            }
            if (price24hAgo === null) {
                price24hAgo = priceNow;
            }
            const change = (price24hAgo === 0) ? 0 : ((priceNow - price24hAgo) / price24hAgo) * 100;
            priceDataMap.set(currency.symbol.toUpperCase(), { now: priceNow, twentyFourHoursAgoPrice: price24hAgo, change: change });
            if (change > bestPerformer.change) {
                bestPerformer = { symbol: currency.symbol, change: change };
            }
        }
        
        // ... (cálculo dos balanços) ...
        let totalBalanceNow = 0;
        let totalBalance24hAgo = 0;
        for (const wallet of wallets) {
            const prices = wallet.currencySymbol ? priceDataMap.get(wallet.currencySymbol.toUpperCase()) : undefined;
            const balance = Number(wallet.balance);
            if (prices && !isNaN(balance)) {
                totalBalanceNow += balance * prices.now;
                totalBalance24hAgo += balance * (prices.twentyFourHoursAgoPrice ?? prices.now);
            }
        }
        const profitBRL = totalBalanceNow - totalBalance24hAgo;
        const profitPercent = (totalBalance24hAgo === 0 || totalBalanceNow === 0) ? 0 : (profitBRL / totalBalance24hAgo) * 100;

        return { totalBalanceBRL: totalBalanceNow, profitBRL, profitPercent, bestPerformer };
    }, [wallets, currencies]);

    // Montar os dados (mantido)
    const statsData = [
        {
            title: 'Balanço Total (BRL)',
            value: formatCurrencyValue(calculatedStats.totalBalanceBRL), // Usará a nova formatação
            Icon: Wallet,
            change: undefined,
        },
        {
            title: 'Lucro/Prejuízo (24h)',
            value: formatCurrencyValue(calculatedStats.profitBRL), // Usará a nova formatação
            change: formatPercentValue(calculatedStats.profitPercent),
            Icon: (calculatedStats.profitBRL ?? 0) >= 0 ? TrendingUp : TrendingDown,
        },
        {
            title: 'Melhor Ativo (24h)',
            value: calculatedStats.bestPerformer.symbol,
            change: formatPercentValue(calculatedStats.bestPerformer.change),
            Icon: TrendingUp,
        },
        {
            title: 'Total de Carteiras',
            value: wallets.length.toString(),
            Icon: Award,
            change: undefined,
        },
    ];

    // Renderização (mantida)
    return (
        <Box
            component={motion.div}
            variants={containerVariants}
            initial="hidden"
            animate="visible"
            sx={{ mb: 4 }}
        >
            <Grid container spacing={3}>
                {statsData.map((stat, index) => (
                    <Grid item xs={12} sm={6} md={3} key={index}>
                        <motion.div variants={itemVariants}>
                            <StatCard 
                                title={stat.title}
                                value={stat.value}
                                Icon={stat.Icon}
                                {...(stat.change !== undefined && { change: stat.change })}
                            />
                        </motion.div>
                    </Grid>
                ))}
            </Grid>
        </Box>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\SwapWidget.tsx ====
// Caminho: frontend/src/features/dashboard/components/SwapWidget.tsx
'use client';
import React, { useState, useMemo } from 'react';
import { Paper, Box, Typography, TextField, Button, Stack, IconButton, MenuItem, CircularProgress } from '@mui/material';
import { ArrowRightLeft } from 'lucide-react';
import { yellowField } from '@/shared/theme/fieldStyles';
// 1. IMPORTAR useAuthUser para pegar o ID do usuário
import { useDashboardWallets, useDashboardCurrencies, useDashboardActions } from '../store/DashboardStore';
import { useAuthUser } from '@/features/auth/store/useAuthStore'; // <-- ADICIONADO
import { useNotification } from '@/shared/context/NotificationContext';
import walletService, { TradeRequestDTO } from '@/features/wallet/services/walletService';

export const SwapWidget = () => {
    const { showNotification } = useNotification();
    const { fetchDashboardData } = useDashboardActions();
    
    const wallets = useDashboardWallets();
    const currencies = useDashboardCurrencies();
    // 2. OBTER O USUÁRIO LOGADO
    const user = useAuthUser(); // <-- ADICIONADO (Contém user.id)
    
    const [fromWalletId, setFromWalletId] = useState<number | string>('');
    const [toCurrencySymbol, setToCurrencySymbol] = useState<string>('');
    const [amountToSpend, setAmountToSpend] = useState<number | string>('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const spendableWallets = useMemo(() => {
        return wallets.filter(w => Number(w.balance) > 0);
    }, [wallets]);

    const receivableCurrencies = useMemo(() => {
        const selectedWalletId = Number(fromWalletId);
        const fromWallet = wallets.find(w => w.id === selectedWalletId);
        if (!fromWallet) return currencies;
        return currencies.filter(c => c.symbol !== fromWallet.currencySymbol);
    }, [currencies, fromWalletId, wallets]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);

        // 3. VERIFICAR SE TEMOS O ID DO USUÁRIO
        if (!user.id) {
             setError("Erro de autenticação. Tente fazer login novamente.");
             return;
        }

        const numericAmount = Number(amountToSpend);
        const numericFromWalletId = Number(fromWalletId);
        const fromWallet = spendableWallets.find(w => w.id === numericFromWalletId);

        if (!fromWallet || !toCurrencySymbol || !numericAmount || numericAmount <= 0) {
            setError("Preencha todos os campos com valores válidos.");
            return;
        }
        if (numericAmount > fromWallet.balance) {
            setError("Saldo insuficiente na carteira de origem.");
            return;
        }

        setIsLoading(true);

        // 4. ADICIONAR O userId AO tradeRequest
        const tradeRequest: TradeRequestDTO = {
            userId: user.id, // <-- ADICIONADO
            fromWalletId: fromWallet.id,
            toCurrencySymbol: toCurrencySymbol,
            amountToSpend: numericAmount,
        };

        try {
            await walletService.trade(tradeRequest);
            showNotification("Troca realizada com sucesso!", "success");
            fetchDashboardData();
            setFromWalletId('');
            setToCurrencySymbol('');
            setAmountToSpend('');
        } catch (error: any) {
            console.error("Swap failed:", error);
            const errorMsg = error.response?.data?.message || "Erro ao realizar a troca.";
            setError(errorMsg);
            showNotification(errorMsg, "error");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        // ... (O JSX do Paper, Stack, TextFields e Button permanece o MESMO) ...
        // ... (Vou omitir o JSX para brevidade, pois a correção do layout (InputLabelProps) já foi feita) ...
         <Paper component="form" onSubmit={handleSubmit} sx={{ p: { xs: 2, md: 3 }, bgcolor: '#1E1E1E', borderRadius: 4, mt: 4 }}>
            <Typography variant="h6" fontWeight="bold" gutterBottom>
                Quick Swap
            </Typography>
            <Stack spacing={2} mt={2}>
                
                <TextField
                    select
                    label="Você Paga (Carteira)"
                    value={fromWalletId}
                    onChange={(e) => setFromWalletId(e.target.value)}
                    sx={yellowField}
                    disabled={isLoading || spendableWallets.length === 0}
                    InputLabelProps={{ shrink: true }} 
                    SelectProps={{ displayEmpty: true }}
                >
                    <MenuItem value="" disabled>
                        {spendableWallets.length === 0 ? "Sem saldo" : "Selecione a carteira"}
                    </MenuItem>
                    {spendableWallets.map(wallet => (
                        <MenuItem key={wallet.id} value={wallet.id}>
                            <Box component="span" sx={{ fontWeight: 'bold' }}>{wallet.name}</Box>
                            <Box component="span" sx={{ color: 'text.secondary', ml: 0.5 }}>
                                ({wallet.balance.toFixed(4)} {wallet.currencySymbol})
                            </Box>
                        </MenuItem>
                    ))}
                </TextField>

                 <TextField 
                    label="Valor a Pagar"
                    type="number"
                    value={amountToSpend}
                    onChange={(e) => setAmountToSpend(e.target.value)}
                    sx={yellowField}
                    disabled={isLoading || !fromWalletId}
                    InputLabelProps={{ shrink: true }}
                    InputProps={{ inputProps: { step: "any", min: 0 } }}
                />
                
                <Box sx={{ display: 'flex', justifyContent: 'center', my: 1 }}>
                    <IconButton sx={{ border: '1px solid #333', borderRadius: '50%', p: 0.5, pointerEvents: 'none' }}>
                        <ArrowRightLeft size={20} />
                    </IconButton>
                </Box>

                <TextField 
                    select
                    label="Você Recebe (Moeda)" 
                    value={toCurrencySymbol}
                    onChange={(e) => setToCurrencySymbol(e.target.value)}
                    sx={yellowField}
                    disabled={isLoading || !fromWalletId}
                    InputLabelProps={{ shrink: true }}
                    SelectProps={{ displayEmpty: true }}
                >
                     <MenuItem value="" disabled>Selecione a moeda</MenuItem>
                     {receivableCurrencies.map(currency => (
                        <MenuItem key={currency.id ?? currency.symbol} value={currency.symbol}>
                             <Box component="span" sx={{ fontWeight: 'bold' }}>{currency.name}</Box>
                             <Box component="span" sx={{ color: 'text.secondary', ml: 0.5 }}>({currency.symbol})</Box>
                        </MenuItem>
                     ))}
                </TextField>

                {error && (
                    <Typography color="error" variant="body2" textAlign="center" fontWeight="bold">
                        {error}
                    </Typography>
                )}
     
                <Button 
                    type="submit"
                    variant="contained" 
                    color="primary" 
                    size="large"
                    disabled={isLoading}
                    sx={{ fontWeight: 'bold', py: 1.5, textTransform: 'none', mt: 1 }}
                >
                    {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Swap Coins'}
                </Button>
            </Stack>
        </Paper>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\WalletCard.tsx ====
// Caminho: frontend/src/features/dashboard/components/WalletCard.tsx
'use client';
import { Paper, Box, Typography, useTheme, Avatar, Button, Stack } from '@mui/material';
import { Wallet } from '@/features/wallet/services/walletService';
import { ArrowDownLeft, ArrowUpRight } from 'lucide-react';

// Função de formatação (agora abrevia K/M/B/T)
const formatCurrencyValue = (value: number | undefined | null): string => {
    const numericValue = Number(value);
    if (isNaN(numericValue) || value === undefined || value === null) {
        return "R$ --";
    }

    // Se for menos de 1000 BRL, mostra o valor completo
    if (numericValue < 1000 && numericValue > -1000) {
        return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    const prefix = "R$ ";
    
    if (numericValue >= 1_000_000_000_000) { // Trilhão (T)
        return prefix + (numericValue / 1_000_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " T";
    }
    if (numericValue >= 1_000_000_000) { // Bilhão (B)
        return prefix + (numericValue / 1_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " B";
    }
    if (numericValue >= 1_000_000) { // Milhão (M)
        return prefix + (numericValue / 1_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " M";
    }
    if (numericValue >= 1_000) { // Mil (K)
        return prefix + (numericValue / 1_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " K";
    }
    
    // Fallback para valores entre 1000 e -1000
    return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2, maximumFractionDigits: 2 });
};

// 1. ATUALIZAR PROPS: Adicionar valueBRL
interface WalletCardProps {
    wallet: Wallet;
    currencySymbol?: string;
    valueBRL: number | undefined; // <-- Valor total em BRL (calculado pelo pai)
    onDepositClick: () => void;
}

export const WalletCard = ({ wallet, currencySymbol, valueBRL, onDepositClick }: WalletCardProps) => {
    const theme = useTheme();
    
    // 2. Definir valores de exibição
    const displayValueBRL = valueBRL; // O valor em R$ (ex: R$ 244,00)
    const displayAmount = Number(wallet.balance); // A quantidade (ex: 0.0000216)
    const displayName = wallet.name;
    const avatarLetter = (currencySymbol || displayName || '?').charAt(0).toUpperCase();

    // Mostrar ações de depósito/saque (RF-04)
    const showActions = wallet.category === 'Spot' || wallet.category === 'Funding';

    return (
        <Paper sx={{ p: 2, bgcolor: '#1E1E1E', borderRadius: 4, height: '100%', display: 'flex', flexDirection: 'column', justifyContent: 'space-between' }}>
            <Box>
                {/* Cabeçalho do Card (Avatar e Nome) */}
                <Box display="flex" alignItems="center" mb={1}>
                    <Avatar sx={{ bgcolor: theme.palette.primary.main, width: 32, height: 32, mr: 1, color: '#0B0B0B', fontWeight:'bold' }}>
                        {avatarLetter}
                    </Avatar>
                    <Typography fontWeight="bold" noWrap title={displayName}>{displayName}</Typography>
                </Box>
                
                {/* 3. EXIBIÇÃO CORRIGIDA */}
                {/* Valor Principal (em BRL) */}
                <Typography variant="h5" fontWeight="bold" noWrap>
                    {formatCurrencyValue(displayValueBRL)} 
                </Typography>
                
                {/* Quantidade (em Cripto/Moeda) */}
                <Typography variant="body2" color="text.secondary" noWrap>
                    {/* Formata a quantidade com 8 casas decimais para cripto, 2 para BRL */}
                    {displayAmount.toFixed(currencySymbol === 'BRL' ? 2 : 8)} {currencySymbol}
                </Typography>
                
                {/* Categoria (Opcional) */}
                <Typography variant="caption" color="text.secondary" sx={{ fontStyle: 'italic' }}>
                    {wallet.category}
                </Typography>
            </Box>

            {/* Botões de Ação */}
            {showActions && (
                <Stack direction="row" spacing={1} sx={{ mt: 2 }}>
                    <Button
                        variant="contained"
                        color="primary"
                        size="small"
                        startIcon={<ArrowDownLeft size={16} />}
                        onClick={onDepositClick}
                        sx={{ flex: 1, fontWeight: 'bold', fontSize: '0.75rem' }}
                        // Desabilita depósito em carteiras Cripto (deve ser via Trade)
                        disabled={wallet.currencySymbol !== 'BRL'} 
                        title={wallet.currencySymbol !== 'BRL' ? "Depósito apenas em BRL" : "Depositar fundos"}
                    >
                        Depositar
                    </Button>
                    <Button
                        variant="outlined"
                        color="inherit"
                        size="small"
                        startIcon={<ArrowUpRight size={16} />}
                        disabled // TODO: Implementar Saque (Withdraw)
                        sx={{ flex: 1, borderColor: '#555', color: '#777', fontSize: '0.75rem' }}
                    >
                        Sacar
                    </Button>
                </Stack>
            )}
        </Paper>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\WalletGrid.tsx ====
// Caminho: frontend/src/features/dashboard/components/WalletGrid.tsx
'use client';
import { Grid, Typography, Box } from '@mui/material';
// 1. RE-ADICIONAR useDashboardCurrencies
import { useDashboardWallets, useDashboardCurrencies } from '../store/DashboardStore'; 
import { WalletCard } from './WalletCard';
import { useState, useMemo } from 'react'; // Adicionar useMemo
import { Wallet } from '@/features/wallet/services/walletService';
// 2. Importar o DepositModal (que já estava)
import DepositModal from '@/features/wallet/components/DepositModal';

export const WalletGrid = () => {
    const wallets = useDashboardWallets();
    // 3. BUSCAR CURRENCIES NOVAMENTE
    const currencies = useDashboardCurrencies(); 

    // 4. ADICIONAR O MAPA DE PREÇOS (Copiado de StatsCards)
    const currentPrices = useMemo(() => {
        return currencies.reduce((map, currency) => {
            if (currency.histories && currency.histories.length > 0 && currency.symbol) {
                // Ordena para garantir o preço mais recente
                const latestHistory = [...currency.histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime())[0];
                if (latestHistory) {
                    map[currency.symbol.toUpperCase()] = latestHistory.price;
                }
            }
            return map;
        }, {} as Record<string, number>);
    }, [currencies]);

    // Lógica do modal (mantida)
    const [depositModalOpen, setDepositModalOpen] = useState(false);
    const [selectedWallet, setSelectedWallet] = useState<Wallet | null>(null);
    const handleOpenDepositModal = (wallet: Wallet) => {
        setSelectedWallet(wallet);
        setDepositModalOpen(true);
    };
    const handleCloseModals = () => {
        setSelectedWallet(null);
        setDepositModalOpen(false);
    };

    if (!wallets || wallets.length === 0) {
        return (
            <Box sx={{ mt: 4, p: 3, bgcolor: '#1E1E1E', borderRadius: 4, textAlign: 'center' }}>
                <Typography variant="h6" fontWeight="bold" sx={{ mb: 1 }}>Suas Carteiras</Typography>
                <Typography color="text.secondary">Nenhuma carteira encontrada.</Typography>
            </Box>
        );
    }

    return (
        <>
            <Typography variant="h6" fontWeight="bold" sx={{ mt: 4, mb: 2 }}>
                Suas Carteiras ({wallets.length})
            </Typography>
            <Grid container spacing={3}>
                {wallets.map(wallet => {
                    // 5. CALCULAR O VALOR BRL AQUI
                    const balanceAsNumber = Number(wallet.balance);
                    
                    // Trata BRL como preço 1.0, senão busca no mapa
                    const price = (wallet.currencySymbol === 'BRL') 
                        ? 1.0 
                        : (wallet.currencySymbol ? currentPrices[wallet.currencySymbol.toUpperCase()] : undefined);

                    const valueBRL = (price !== undefined && !isNaN(balanceAsNumber)) 
                        ? (balanceAsNumber * price) 
                        : undefined; // Passa undefined se o preço não for encontrado

                    return (
                         <Grid item xs={12} sm={6} md={3} key={wallet.id}>
                            <WalletCard 
                                wallet={wallet} 
                                currencySymbol={wallet.currencySymbol}
                                valueBRL={valueBRL} // <-- 6. PASSAR O VALOR CALCULADO
                                onDepositClick={() => handleOpenDepositModal(wallet)}
                            />
                        </Grid>
                    );
                })}
            </Grid>

            {/* Modal de Depósito */}
            <DepositModal
                open={depositModalOpen}
                onClose={handleCloseModals}
                wallet={selectedWallet}
            />
        </>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\pages\DashboardPage.tsx ====
// Caminho: frontend/src/features/dashboard/pages/DashboardPage.tsx
'use client';
// 1. Importar useState e Button
import React, { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';

import { Box, CircularProgress, Container, Grid, Typography, Button } from '@mui/material'; // Corrigido 'f6rom' para 'from'
// --------------------
import { useDashboardLoading, useDashboardError, useDashboardActions } from '@/features/dashboard/store/DashboardStore';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { OverviewChart } from '@/features/dashboard/components/OverviewChart';
import { HotList } from '@/features/dashboard/components/HotList';
import { WalletGrid } from '@/features/dashboard/components/WalletGrid';
import { SwapWidget } from '@/features/dashboard/components/SwapWidget';
import { PlusCircle } from 'lucide-react'; // Ícone para o botão
// --- DESCOMENTADO ---
import CreateWalletModal from '@/features/wallet/components/CreateWalletModal'; // Importa o modal
// --------------------

export default function DashboardPage() {
    const router = useRouter();
    const loading = useDashboardLoading();
    const error = useDashboardError();
    const { fetchDashboardData } = useDashboardActions();

    // Estado para controlar a visibilidade do modal
    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

    useEffect(() => {
        console.log("DashboardPage: Fetching dashboard data...");
        fetchDashboardData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    // Tratamento de Erro
     if (error) {
       return (
         <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh', flexDirection: 'column' }}>
            <Typography color="error" variant="h6">Erro ao carregar dados do Dashboard</Typography>
            <Typography color="error" >{error}</Typography>
            {/* <Button variant="contained" onClick={fetchDashboardData}>Tentar Novamente</Button> */}
         </Box>
       );
    }

    // Indicador de Carregamento
    if (loading) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <CircularProgress color="primary" />
           <Typography sx={{ ml: 2, color: 'primary.main' }}>Carregando Dashboard...</Typography>
        </Box>
      );
    }

    // Conteúdo Principal
    return (
        <Container maxWidth="xl" sx={{ py: 4 }}>
            {/* Título da Página e Botão */}
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
                <Typography variant="h4" fontWeight="bold" gutterBottom sx={{ mb: 0 }}>
                    Dashboard
                </Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<PlusCircle size={18} />}
                    onClick={() => setIsCreateModalOpen(true)} // Abre o modal
                    sx={{ fontWeight: 'bold' }}
                >
                    Adicionar Carteira
                </Button>
            </Box>

            {/* Componentes do Dashboard */}
            <StatsCards />

            <Grid container spacing={4}>
                <Grid item xs={12} lg={8}>
                    <OverviewChart />
                    <WalletGrid />
                </Grid>
                <Grid item xs={12} lg={4}>
                    <HotList />
                    <SwapWidget />
                </Grid>
            </Grid>

            {/* --- DESCOMENTADO --- */}
            {/* Renderiza o Modal de Criação */}
            <CreateWalletModal
                open={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
            />
            {/* -------------------- */}
        </Container>
    );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\store\DashboardStore.ts ====
// Caminho: frontend/src/features/dashboard/store/DashboardStore.ts

import { create } from 'zustand';
import { Currency } from '@/features/currency/types/Currency';
import currencyService from '@/features/currency/services/currencyService';
import walletService, { Wallet } from '@/features/wallet/services/walletService'; // Ajuste o caminho se necessário
import { useAuthStore } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho se necessário

interface DashboardState {
  currencies: Currency[];
  wallets: Wallet[];
  selectedCoin: Currency | null;
  loading: boolean;
  error: string | null;
  fetchDashboardData: () => Promise<void>;
  setSelectedCoin: (coin: Currency | null) => void;
  // Adicionado 'actions' ao estado para seleção estável
  actions: {
      fetchDashboardData: () => Promise<void>;
      setSelectedCoin: (coin: Currency | null) => void;
  };
}

const initialState = {
  currencies: [],
  wallets: [],
  selectedCoin: null,
  loading: true,
  error: null,
};

export const useDashboardStore = create<DashboardState>((set, get) => ({
  ...initialState,
  fetchDashboardData: async () => {
    const { isAuthenticated, user } = useAuthStore.getState();
    const userId = user.id;

    if (!isAuthenticated || !userId) {
      console.warn("DashboardStore: User not authenticated or userId not available. Skipping data fetch.");
      // Limpa dados e para o loading, define erro
      set({ ...initialState, loading: false, error: "Usuário não autenticado." });
      return;
    }

    console.log(`DashboardStore: Fetching data for userId: ${userId}`);
    set({ loading: true, error: null });

    try {
      const [currencyData, walletData] = await Promise.all([
        currencyService.getAll(),
        walletService.getUserWallets(userId)
      ]);

      console.log("DashboardStore: Currencies fetched:", currencyData);
      console.log("DashboardStore: Wallets fetched:", walletData);

      set({
        currencies: currencyData,
        wallets: walletData,
        selectedCoin: currencyData.length > 0 ? currencyData[0] : null,
        loading: false,
        error: null,
      });
      console.log("DashboardStore: State updated successfully.");

    } catch (error: any) {
      console.error("DashboardStore: Error fetching data:", error);
      const errorMessage = error.response?.data?.message || "Falha ao carregar dados do dashboard.";
      set({
        ...initialState, // Reseta dados em caso de erro
        loading: false,
        error: errorMessage
       });
    }
  },

  setSelectedCoin: (coin) => {
    set({ selectedCoin: coin });
  },

  // Popula o objeto 'actions' com as funções definidas acima
  // Isso garante que a referência ao objeto 'actions' seja estável
  actions: {
      fetchDashboardData: () => get().fetchDashboardData(),
      setSelectedCoin: (coin) => get().setSelectedCoin(coin),
  }
}));

// Hooks de conveniência
export const useDashboardCurrencies = () => useDashboardStore((state) => state.currencies);
export const useDashboardWallets = () => useDashboardStore((state) => state.wallets);
export const useDashboardSelectedCoin = () => useDashboardStore((state) => state.selectedCoin);
export const useDashboardLoading = () => useDashboardStore((state) => state.loading);
export const useDashboardError = () => useDashboardStore((state) => state.error);

// Hook de ações corrigido para selecionar o objeto 'actions' estável
export const useDashboardActions = () => useDashboardStore((state) => state.actions);

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\components\AddUserModal.tsx ====
"use client";

import React, { useState } from 'react';
import Modal from '@/shared/components/Modal';
import UserForm from './UserForm';
import { UserFormValues } from '../types/UserFormValues';
import { useUsersStore } from '../store/usersStore';

interface AddUserModalProps {
  open: boolean;
  onClose: () => void;
}

const AddUserModal: React.FC<AddUserModalProps> = ({ open, onClose }) => {
  const { addUser } = useUsersStore();
  const [isLoading, setIsLoading] = useState(false); // Este estado já existia

  const handleSubmit = async (values: UserFormValues) => {
    setIsLoading(true);
    const success = await addUser(values);
    setIsLoading(false);

    if (success) {
      alert("Usuário adicionado com sucesso!");
      onClose();
    } else {
      alert("Falha ao adicionar usuário. Tente novamente.");
    }
  };

  return (
    <Modal open={open} onClose={onClose} title="Adicionar Novo Usuário">
      <UserForm
        onSubmit={handleSubmit}
        buttonLabel="Criar Usuário"
        isLoading={isLoading} // <-- PASSE A PROP AQUI
      />
    </Modal>
  );
};

export default AddUserModal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\components\DeleteConfirmationModal.tsx ====
"use client";

import React, { useState } from 'react';
import Modal from '@/shared/components/Modal';
import { useUsersStore } from '../store/usersStore';
import { User } from '../services/userService';
import { Box, Typography, Button, CircularProgress } from '@mui/material';
import { AlertCircle } from 'lucide-react'; // Ícone de alerta, como na referência

interface DeleteConfirmationModalProps {
  open: boolean;
  onClose: () => void;
  user: User | null;
}

const DeleteConfirmationModal: React.FC<DeleteConfirmationModalProps> = ({ open, onClose, user }) => {
  const { deleteUser } = useUsersStore();
  const [isLoading, setIsLoading] = useState(false);

  const handleConfirmDelete = async () => {
    if (!user) return;

    setIsLoading(true);
    const success = await deleteUser(user.id);
    setIsLoading(false);

    if (success) {
      alert("Usuário deletado com sucesso!"); // Usando alert por enquanto
      onClose();
    } else {
      alert("Falha ao deletar usuário.");
    }
  };

  if (!user) return null; // Não renderiza nada se não houver um usuário selecionado

  return (
    <Modal open={open} onClose={onClose} title="Confirmar Exclusão">
      <Box sx={{ textAlign: 'center' }}>
        <AlertCircle size={48} color="#ef4444" style={{ margin: '0 auto 16px' }} />
        <Typography variant="h6" component="h3" fontWeight="bold">
          Você tem certeza?
        </Typography>
        <Typography sx={{ mt: 1, color: 'text.secondary' }}>
          Você está prestes a deletar o usuário{' '}
          <Box component="span" fontWeight="bold">{user.name}</Box>.
          Esta ação não pode ser desfeita.
        </Typography>
        <Box sx={{ mt: 4, display: 'flex', justifyContent: 'center', gap: 2 }}>
          <Button
            variant="outlined"
            onClick={onClose}
            disabled={isLoading}
          >
            Cancelar
          </Button>
          <Button
            variant="contained"
            color="error" // Cor para indicar uma ação destrutiva
            onClick={handleConfirmDelete}
            disabled={isLoading}
            sx={{ minWidth: 110 }}
          >
            {isLoading ? (
              <CircularProgress size={24} color="inherit" />
            ) : (
              'Deletar'
            )}
          </Button>
        </Box>
      </Box>
    </Modal>
  );
};

export default DeleteConfirmationModal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\components\EditUserModal.tsx ====
"use client";

import React, { useState, useEffect } from 'react';
import Modal from '@/shared/components/Modal';
import UserForm from './UserForm';
import { UserFormValues } from '../types/UserFormValues';
import { useUsersStore } from '../store/usersStore';
import { User } from '../services/userService';

interface EditUserModalProps {
  open: boolean;
  onClose: () => void;
  user: User | null; // Recebe o usuário a ser editado
}

const EditUserModal: React.FC<EditUserModalProps> = ({ open, onClose, user }) => {
  const { updateUser } = useUsersStore();
  const [isLoading, setIsLoading] = useState(false);

  // Prepara os valores iniciais para o formulário.
  // A senha fica em branco; o usuário só digita se quiser alterar.
  const initialValues = user ? {
    name: user.name,
    email: user.email,
    phone: user.phone,
    address: user.address,
    password: '', // Deixar em branco por segurança
    photo: user.photo,
  } : undefined;

  const handleSubmit = async (values: UserFormValues) => {
    if (!user) return; // Verificação de segurança

    setIsLoading(true);

    // Lógica para não enviar a senha se o campo estiver vazio
    const dataToUpdate: Partial<UserFormValues> = { ...values };
    if (!dataToUpdate.password?.trim()) {
      delete dataToUpdate.password;
    }

    const success = await updateUser(user.id, dataToUpdate);
    setIsLoading(false);

    if (success) {
      alert("Usuário atualizado com sucesso!");
      onClose();
    } else {
      alert("Falha ao atualizar usuário. Tente novamente.");
    }
  };

  return (
    <Modal open={open} onClose={onClose} title={`Editar Usuário: ${user?.name}`}>
      {/* O formulário só é renderizado se tivermos os valores iniciais,
        evitando qualquer erro caso o modal seja aberto sem um usuário.
      */}
      {initialValues && (
        <UserForm
          initialValues={initialValues}
          onSubmit={handleSubmit}
          buttonLabel="Salvar Alterações"
          isLoading={isLoading}
        />
      )}
    </Modal>
  );
};

export default EditUserModal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\components\UserForm.tsx ====
"use client";

import React, { useState } from "react";
import { UserFormValues } from "@/features/user/types/UserFormValues";
import TextField from "@mui/material/TextField";
import Box from "@mui/material/Box";
import MainButton from "@/shared/components/MainButton";
import { yellowField } from "@/shared/theme/fieldStyles";
import { CircularProgress } from "@mui/material"; // <-- 1. Importar o CircularProgress

interface UserFormProps {
  initialValues?: UserFormValues;
  onSubmit: (values: UserFormValues) => void;
  buttonLabel?: string;
  isLoading?: boolean; // <-- 2. Adicionar a nova prop
}

const fields = [
  { label: "Nome", id: "name", type: "text", placeholder: "Seu nome" },
  { label: "Email", id: "email", type: "email", placeholder: "Seu email" },
  { label: "Telefone", id: "phone", type: "text", placeholder: "Seu telefone" },
  { label: "Endereço", id: "address", type: "text", placeholder: "Seu endereço" },
  { label: "Senha", id: "password", type: "password", placeholder: "Sua senha" },
  { label: "Foto (URL)", id: "photo", type: "text", placeholder: "URL da sua foto" },
];

const UserForm: React.FC<UserFormProps> = ({
  initialValues,
  onSubmit,
  buttonLabel,
  isLoading, // <-- 3. Receber a prop
}) => {
  const [values, setValues] = useState<UserFormValues>(
    initialValues || {
      name: "",
      email: "",
      phone: "",
      address: "",
      password: "",
      photo: "",
    }
  );

  // ... (restante do código do formulário permanece igual: errors, handleChange, etc.)
  const [errors, setErrors] = useState<{ [key: string]: string }>({});

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setValues({ ...values, [name]: value });
    setErrors({ ...errors, [name]: "" });
  };

  const validateForm = (): boolean => {
    const newErrors: { [key: string]: string } = {};

    if (!values.name) newErrors.name = "O nome é obrigatório.";
    if (!values.email) {
      newErrors.email = "O email é obrigatório.";
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      newErrors.email = "Formato de email inválido.";
    }
    if (!values.phone) newErrors.phone = "O telefone é obrigatório.";
    if (!values.password) newErrors.password = "A senha é obrigatória.";

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (validateForm()) {
      onSubmit(values);
    }
  };


  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ display: "flex", flexDirection: "column", gap: 3 }}>
      {fields.map(({ label, id, type, placeholder }) => (
        <TextField
          key={id}
          label={label}
          name={id}
          type={type}
          value={values[id as keyof UserFormValues] as string}
          onChange={handleChange}
          placeholder={placeholder}
          error={!!errors[id]}
          helperText={errors[id]}
          sx={yellowField}
          fullWidth
        />
      ))}
      {/* 4. Lógica do botão atualizada */}
      <MainButton type="submit" disabled={isLoading}>
        {isLoading ? (
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
            <CircularProgress size={20} color="inherit" />
            Criando...
          </Box>
        ) : (
          buttonLabel || "Registrar"
        )}
      </MainButton>
    </Box>
  );
};

export default UserForm;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\pages\UserPage.tsx ====
"use client";

import React, { useEffect, useState } from "react";
import { useUsersStore } from "@/features/user/store/usersStore";
import { User } from "@/features/user/services/userService";

// MUI Components
import {
  Box, Typography, Paper, Table, TableBody, TableCell,
  TableContainer, TableHead, TableRow, CircularProgress,
  IconButton, Avatar, Tooltip, TextField, InputAdornment
} from "@mui/material";

// Lucide Icons
import { Users as UsersIcon, UserPlus, Edit, Trash2, Search } from 'lucide-react';

// Nossos componentes de Modal
import AddUserModal from '@/features/user/components/AddUserModal';
import EditUserModal from '@/features/user/components/EditUserModal';
import DeleteConfirmationModal from '@/features/user/components/DeleteConfirmationModal'; // <-- 1. IMPORTAÇÃO

export default function UsersPage() {
  const { users, loading, error, fetchUsers } = useUsersStore();
  const [searchTerm, setSearchTerm] = useState('');
  const [addModalOpen, setAddModalOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const handleOpenEditModal = (user: User) => {
    setSelectedUser(user);
    setEditModalOpen(true);
  };
  
  const handleOpenDeleteModal = (user: User) => {
    setSelectedUser(user);
    setDeleteModalOpen(true);
  };

  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    user.email.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <Box sx={{ p: { xs: 2, md: 4 }, maxWidth: 1200, mx: "auto" }}>
      {/* ... (Cabeçalho da página e Paper da tabela) ... */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={4}>
        <Typography variant="h4" fontWeight="bold" color="text.primary" sx={{ display: 'flex', alignItems: 'center', gap: 1.5 }}>
          <UsersIcon size={32} color="#fcd34d" />
          Gerenciamento de Usuários
        </Typography>
        <button
          onClick={() => setAddModalOpen(true)}
          className="flex items-center space-x-2 px-4 py-2 bg-yellow-400 hover:bg-yellow-500 text-black rounded-md transition-colors duration-200 shadow-sm font-bold"
        >
          <UserPlus size={20} />
          <span>Adicionar Usuário</span>
        </button>
      </Box>

      <Paper sx={{ p: 3, bgcolor: '#1E1E1E', borderRadius: 4 }}>
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
            <Typography variant="h6">
                Todos os Usuários ({filteredUsers.length})
            </Typography>
            <TextField
                variant="outlined"
                size="small"
                placeholder="Pesquisar..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                InputProps={{
                    startAdornment: (
                        <InputAdornment position="start">
                            <Search size={18} />
                        </InputAdornment>
                    ),
                }}
            />
        </Box>
        
        {loading ? (
            <Box display="flex" justifyContent="center" py={10}>
                <CircularProgress color="primary" />
            </Box>
        ) : error ? (
            <Typography color="error" textAlign="center" py={10}> {error} </Typography>
        ) : (
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }}>Usuário</TableCell>
                  <TableCell sx={{ fontWeight: "bold", color: "#fcd34d" }}>Contato</TableCell>
                  <TableCell sx={{ fontWeight: "bold", color: "#fcd34d", textAlign: 'center' }}>Ações</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredUsers.map((user) => (
                  <TableRow key={user.id} hover sx={{ '&:last-child td, &:last-child th': { border: 0 } }}>
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar src={user.photo} alt={user.name}>
                          {user.name.charAt(0)}
                        </Avatar>
                        <Box>
                            <Typography fontWeight="bold" color="text.primary">{user.name}</Typography>
                            <Typography variant="body2" color="text.secondary">{user.email}</Typography>
                        </Box>
                      </Box>
                    </TableCell>
                    <TableCell>
                        <Typography variant="body2" color="text.primary">{user.phone}</Typography>
                        <Typography variant="body2" color="text.secondary">{user.address}</Typography>
                    </TableCell>
                    <TableCell align="center">
                      <Tooltip title="Editar">
                        <IconButton onClick={() => handleOpenEditModal(user)}>
                          <Edit size={20} color="#fcd34d" />
                        </IconButton>
                      </Tooltip>
                      <Tooltip title="Deletar">
                        <IconButton onClick={() => handleOpenDeleteModal(user)}>
                          <Trash2 size={20} color="#ef4444" />
                        </IconButton>
                      </Tooltip>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        )}
      </Paper>
      
      {/* Nossos modais renderizados */}
      <AddUserModal open={addModalOpen} onClose={() => setAddModalOpen(false)} />
      <EditUserModal open={editModalOpen} onClose={() => setEditModalOpen(false)} user={selectedUser} />
      
      {/* 2. ATIVAÇÃO DO MODAL DE DELEÇÃO */}
      <DeleteConfirmationModal open={deleteModalOpen} onClose={() => setDeleteModalOpen(false)} user={selectedUser} />
    </Box>
  );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\services\userService.ts ====
import apiClient from '@/shared/api/apiClient';
import { userAPI } from '@/shared/api/api';

export interface User {
  id: number;
  name: string;
  email: string;
  password?: string;
  photo: string;
  phone: string;
  address: string;
}

const userServiceObject = {
  getAll: async (): Promise<User[]> => {
    const response = await apiClient.get(userAPI.getAll());
    return response.data;
  },

  getById: async (id: number): Promise<User> => {
    if (!id || typeof id !== "number" || isNaN(id) || id <= 0) {
      throw new Error("ID de usuário inválido.");
    }
    const response = await apiClient.get(userAPI.getById(id));
    return response.data;
  },

  create: async (user: Omit<User, 'id'>): Promise<User> => {
    const response = await apiClient.post(userAPI.create(), user);
    return response.data;
  },

  update: async (id: number, user: Partial<User>): Promise<User> => {
    if (!id || typeof id !== "number" || isNaN(id) || id <= 0) {
      throw new Error("ID de usuário inválido.");
    }
    const response = await apiClient.put(userAPI.update(id), user);
    return response.data;
  },

  delete: async (id: number): Promise<void> => {
    if (!id || typeof id !== "number" || isNaN(id) || id <= 0) {
      throw new Error("ID de usuário inválido.");
    }
    await apiClient.delete(userAPI.delete(id));
  },
};

// CORREÇÃO: Usando exportação nomeada em vez de default
export const userService = userServiceObject;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\store\usersStore.ts ====
import { create } from 'zustand';
import { userService, User } from '@/features/user/services/userService';
import { UserFormValues } from '../types/UserFormValues';

interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  fetchUsers: () => Promise<void>;
  addUser: (userData: UserFormValues) => Promise<boolean>; // Retorna true em sucesso
  updateUser: (id: number, userData: Partial<UserFormValues>) => Promise<boolean>;
  deleteUser: (id: number) => Promise<boolean>;
}

export const useUsersStore = create<UserState>((set, get) => ({
  users: [],
  loading: false,
  error: null,

  fetchUsers: async () => {
    set({ loading: true, error: null });
    try {
      const users = await userService.getAll();
      set({ users, loading: false });
    } catch (err) {
      set({ error: 'Falha ao carregar usuários.', loading: false });
    }
  },

  addUser: async (userData) => {
    try {
      // Omit 'id' for creation
      const newUser = await userService.create(userData);
      set((state) => ({ users: [...state.users, newUser] }));
      return true;
    } catch (err) {
      console.error("Erro ao adicionar usuário:", err);
      return false;
    }
  },

  updateUser: async (id, userData) => {
    try {
      const updatedUser = await userService.update(id, userData);
      set((state) => ({
        users: state.users.map((user) => (user.id === id ? updatedUser : user)),
      }));
      return true;
    } catch (err) {
      console.error("Erro ao atualizar usuário:", err);
      return false;
    }
  },

  deleteUser: async (id) => {
    try {
      await userService.delete(id);
      set((state) => ({
        users: state.users.filter((user) => user.id !== id),
      }));
      return true;
    } catch (err) {
      console.error("Erro ao deletar usuário:", err);
      return false;
    }
  },
}));

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\user\types\UserFormValues.ts ====
export interface UserFormValues {
  name: string;
  email: string;
  phone: string;
  address: string;
  password: string;
  photo: string;
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\wallet\components\CreateWalletModal.tsx ====
// Caminho: frontend/src/features/wallet/components/CreateWalletModal.tsx
'use client';

import React, { useState } from 'react';
import Modal from '@/shared/components/Modal';
import { Box } from '@mui/material';

// 1. Importar o formulário E a interface WalletFormValues (o que o form envia)
import WalletForm, { WalletFormValues } from './WalletForm';

// 2. Importar o DTO de criação (para verificar o tipo final)
import { CreateWalletDTO } from '../services/walletService';

import { useAuthStore } from '@/features/auth/store/useAuthStore';
import walletService from '../services/walletService';
import { useDashboardActions } from '@/features/dashboard/store/DashboardStore';
import { useNotification } from '@/shared/context/NotificationContext';

interface CreateWalletModalProps {
  open: boolean;
  onClose: () => void;
}

const CreateWalletModal: React.FC<CreateWalletModalProps> = ({ open, onClose }) => {
  const { user } = useAuthStore();
  const { fetchDashboardData } = useDashboardActions();
  const { showNotification } = useNotification();
  const [isLoading, setIsLoading] = useState(false);

  // 3. ASSINATURA CORRIGIDA:
  // Recebe 'values' no formato que o WalletForm envia
  const handleSubmit = async (values: WalletFormValues & { balance: 0 }) => {
    
    // 4. Verifica o userId
    if (!user.id) {
        showNotification("Erro: ID do usuário não encontrado. Faça login novamente.", "error");
        return;
    }
    
    // 5. Monta o DTO completo aqui, adicionando o userId
    const walletDataToSend: CreateWalletDTO = { 
        ...values, // Contém name, category, currencySymbol, balance: 0
        userId: user.id // Adiciona o userId
    };
    
    setIsLoading(true);
    console.log("Creating wallet with data:", walletDataToSend);
    try {
        // Envia o DTO completo para o serviço
        await walletService.createWallet(walletDataToSend);
        
        showNotification(`Carteira "${values.name}" criada com sucesso!`, "success");
        fetchDashboardData(); // Rebusca dados do dashboard
        onClose(); // Fecha o modal
    } catch (error: any) {
        console.error("Failed to create wallet:", error);
        showNotification(error.response?.data?.message || "Erro desconhecido ao criar carteira.", "error");
    } finally {
        setIsLoading(false);
    }
  };

  return (
    <Modal open={open} onClose={onClose} title="Criar Nova Carteira">
      <WalletForm
          onSubmit={handleSubmit} // Agora os tipos são compatíveis
          isLoading={isLoading}
          onCancel={onClose}
      />
    </Modal>
  );
};

export default CreateWalletModal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\wallet\components\DepositForm.tsx ====
// Caminho: frontend/src/features/wallet/components/DepositForm.tsx
'use client';

import React, { useState } from 'react';
import { TextField, Button, Stack, CircularProgress, Box } from '@mui/material';
import { yellowField } from '@/shared/theme/fieldStyles';

export interface DepositFormValues {
  amount: number;
}

interface DepositFormProps {
  onSubmit: (values: DepositFormValues) => Promise<void>;
  isLoading?: boolean;
  onCancel: () => void;
  currencySymbol: string; // Para exibir "Valor (BRL)"
}

const DepositForm: React.FC<DepositFormProps> = ({ onSubmit, isLoading, onCancel, currencySymbol }) => {
  const [amount, setAmount] = useState<number | string>(''); // Usar string para controlo de input
  const [error, setError] = useState<string | null>(null);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    // Permite números e um único ponto decimal
    if (value === '' || /^\d*\.?\d*$/.test(value)) {
      setAmount(value);
      setError(null);
    }
  };

  const validate = (): boolean => {
    const numericAmount = Number(amount);
    if (isNaN(numericAmount) || numericAmount <= 0) {
      setError('O valor deve ser um número positivo.');
      return false;
    }
    setError(null);
    return true;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;
    await onSubmit({ amount: Number(amount) });
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
      <TextField
        name="amount"
        label={`Valor a Depositar (${currencySymbol})`}
        type="text" // Usar 'text' para melhor controlo do input decimal, validamos manualmente
        value={amount}
        onChange={handleChange}
        required
        fullWidth
        sx={yellowField}
        error={!!error}
        helperText={error || "Ex: 1000.50"}
        disabled={isLoading}
        autoFocus // Foca neste campo quando o modal abre
      />
      <Stack direction="row" spacing={2} justifyContent="flex-end" sx={{ mt: 1 }}>
         <Button
           type="button"
           variant="outlined"
           color="inherit"
           onClick={onCancel}
           disabled={isLoading}
           sx={{ borderColor: '#ccc', color: '#ccc' }}
         >
           Cancelar
         </Button>
        <Button
            type="submit"
            variant="contained"
            color="primary"
            disabled={isLoading}
            sx={{ minWidth: 120 }}
        >
            {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Depositar'}
        </Button>
      </Stack>
    </Box>
  );
};

export default DepositForm;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\wallet\components\DepositModal.tsx ====
// Caminho: frontend/src/features/wallet/components/DepositModal.tsx
'use client';

import React, { useState } from 'react';
import Modal from '@/shared/components/Modal';
import DepositForm, { DepositFormValues } from './DepositForm';
import { Wallet } from '../services/walletService'; // Importar a interface Wallet
import { useAuthStore } from '@/features/auth/store/useAuthStore';
import walletService from '../services/walletService';
import { useDashboardActions } from '@/features/dashboard/store/DashboardStore';
import { useNotification } from '@/shared/context/NotificationContext';
import { Typography } from '@mui/material';

interface DepositModalProps {
  open: boolean;
  onClose: () => void;
  wallet: Wallet | null; // A carteira na qual depositar
}

const DepositModal: React.FC<DepositModalProps> = ({ open, onClose, wallet }) => {
  const { fetchDashboardData } = useDashboardActions();
  const { showNotification } = useNotification();
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (values: DepositFormValues) => {
    if (!wallet) {
        showNotification("Erro: Carteira não selecionada.", "error");
        return;
    }
    
    setIsLoading(true);
    console.log(`DepositModal: Attempting to deposit ${values.amount} into wallet ${wallet.id}`);
    try {
        await walletService.deposit(wallet.id, { amount: values.amount });
        
        showNotification(`Depósito de ${values.amount} ${wallet.currencySymbol} realizado com sucesso!`, "success");
        fetchDashboardData(); // Rebusca dados do dashboard (atualiza saldos)
        onClose(); // Fecha o modal
    } catch (error: any) {
        console.error("Failed to deposit:", error);
        showNotification(error.response?.data?.message || "Erro desconhecido ao realizar depósito.", "error");
    } finally {
        setIsLoading(false);
    }
  };

  // Se 'wallet' for nulo, não renderiza nada (segurança)
  if (!wallet) return null;

  return (
    <Modal open={open} onClose={onClose} title={`Depositar em ${wallet.name} (${wallet.currencySymbol})`}>
       <DepositForm
          onSubmit={handleSubmit}
          isLoading={isLoading}
          onCancel={onClose}
          currencySymbol={wallet.currencySymbol} // Passa o símbolo para o formulário
      />
    </Modal>
  );
};

export default DepositModal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\wallet\components\WalletForm.tsx ====
// Caminho: frontend/src/features/wallet/components/WalletForm.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { TextField, Button, MenuItem, Stack, CircularProgress, Box, Typography } from '@mui/material';
import { WalletCategory } from '../services/walletService';
import { yellowField } from '@/shared/theme/fieldStyles';
import { useDashboardCurrencies } from '@/features/dashboard/store/DashboardStore';

// Interface de valores (REMOVIDO 'balance')
export interface WalletFormValues {
  name: string;
  category: WalletCategory;
  currencySymbol: string;
}

interface WalletFormProps {
  // Ação de submit agora espera 'balance: 0'
  onSubmit: (values: WalletFormValues & { balance: 0 }) => Promise<void>;
  isLoading?: boolean;
  onCancel?: () => void;
}

const categoryOptions: WalletCategory[] = ["Spot", "Funding", "Overview"];

const WalletForm: React.FC<WalletFormProps> = ({ onSubmit, isLoading, onCancel }) => {
  const availableCurrencies = useDashboardCurrencies();

  const [values, setValues] = useState<WalletFormValues>({
    name: '',
    category: 'Spot',
    currencySymbol: '',
  });
  const [errors, setErrors] = useState<{ name?: string, currencySymbol?: string }>({});

  // useEffect para definir moeda padrão (corrigido)
  useEffect(() => {
    if (availableCurrencies.length > 0) {
      setValues((currentValues) => {
        if (!currentValues.currencySymbol && availableCurrencies[0]?.symbol) {
          return { ...currentValues, currencySymbol: availableCurrencies[0].symbol };
        }
        return currentValues;
      });
    }
  }, [availableCurrencies]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setValues((prev) => ({
      ...prev,
      [name]: value, // Removida lógica de 'balance'
    }));
    // Limpa erros
    if (name === 'name' && errors.name) {
        setErrors(prev => ({ ...prev, name: undefined }));
    }
    if (name === 'currencySymbol' && errors.currencySymbol) {
         setErrors(prev => ({ ...prev, currencySymbol: undefined }));
    }
  };

  const validate = (): boolean => {
      const newErrors: { name?: string, currencySymbol?: string } = {};
      if (!values.name.trim()) {
          newErrors.name = 'O nome da carteira é obrigatório.';
      }
      if (!values.currencySymbol) {
           newErrors.currencySymbol = 'Selecione a moeda.';
      }
      setErrors(newErrors);
      return Object.keys(newErrors).length === 0;
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validate()) return;
    
    // *** ALTERAÇÃO CRÍTICA: Envia sempre balance: 0 ***
    await onSubmit({ ...values, balance: 0 });
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
      {/* Campo Nome */}
      <TextField
        name="name"
        label="Nome da Carteira"
        placeholder='Ex: "Minha Carteira Bitcoin" ou "Conta Spot"'
        value={values.name}
        onChange={handleChange}
        required
        fullWidth
        sx={yellowField}
        error={!!errors.name}
        helperText={errors.name}
        disabled={isLoading}
      />

      {/* Campo Select para Moeda */}
      <TextField
        select
        name="currencySymbol"
        label="Moeda"
        value={values.currencySymbol}
        onChange={handleChange}
        required
        fullWidth
        sx={yellowField}
        error={!!errors.currencySymbol}
        helperText={errors.currencySymbol}
        disabled={isLoading || availableCurrencies.length === 0}
      >
        {!values.currencySymbol && <MenuItem value="" disabled>Selecione...</MenuItem>}
        {availableCurrencies.length === 0 && <MenuItem value="" disabled>Carregando moedas...</MenuItem>}
        {availableCurrencies.map((currency) => (
          <MenuItem key={currency.id ?? currency.symbol} value={currency.symbol}>
            <Box component="span" sx={{ fontWeight: 'bold' }}>{currency.name}</Box>
            <Box component="span" sx={{ color: 'text.secondary', ml: 0.5 }}>({currency.symbol})</Box>
          </MenuItem>
        ))}
      </TextField>

      {/* Campo Categoria */}
      <TextField
        select
        name="category"
        label="Categoria"
        value={values.category}
        onChange={handleChange}
        required
        fullWidth
        sx={yellowField}
        disabled={isLoading}
      >
        {categoryOptions.map((option) => (
          <MenuItem key={option} value={option}>
            {option}
          </MenuItem>
        ))}
      </TextField>

      {/* *** CAMPO SALDO INICIAL REMOVIDO *** */}
      
      {/* Botões */}
      <Stack direction="row" spacing={2} justifyContent="flex-end" sx={{ mt: 1 }}>
         {onCancel && (
            <Button
              type="button"
              variant="outlined"
              color="inherit"
              onClick={onCancel}
              disabled={isLoading}
              sx={{ borderColor: '#ccc', color: '#ccc' }}
            >
              Cancelar
            </Button>
          )}
        <Button
            type="submit"
            variant="contained"
            color="primary"
            disabled={isLoading}
            sx={{ minWidth: 120 }}
        >
            {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Criar Carteira'}
        </Button>
      </Stack>
    </Box>
  );
};

export default WalletForm;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\wallet\services\walletService.ts ====
// Caminho: src/features/wallet/services/walletService.ts
import apiClient from '@/shared/api/apiClient';
import { walletAPI } from '@/shared/api/api';

// --- Interfaces ---

export type WalletCategory = "Overview" | "Spot" | "Funding";

export interface Wallet {
  id: number;
  userId: number;
  name: string;
  category: WalletCategory;
  currencySymbol: string;
  balance: number;
  createdAt: string;
}

// Interface que corresponde ao WalletTransactionDTO do C#
export interface WalletTransaction {
  id: number;
  createdAt: string;
  type: number; // 0: Deposit, 1: Withdraw, 2: Transfer
  amount: number;
  walletId: number;
  currencySymbol: string;
  notes: string;
}

export interface CreateWalletDTO {
  userId: number;
  name: string;
  category: WalletCategory;
  currencySymbol: string;
  balance: number;
}

export interface DepositWithdrawDTO {
  amount: number;
}

export interface TransferDTO {
  fromWalletId: number;
  toWalletId: number;
  amount: number;
}

export interface TradeRequestDTO {
  userId: number;
  fromWalletId: number;
  toCurrencySymbol: string;
  amountToSpend: number;
}

export interface TradeResponseDTO {
  status: string;
  newBalances: Record<string, number>;
}

// --- Serviço ---
const walletService = {
  getUserWallets: async (userId: number): Promise<Wallet[]> => {
    if (!userId || userId <= 0) throw new Error("ID de usuário inválido.");
    const response = await apiClient.get<Wallet[]>(walletAPI.getUserWallets(userId));
    return response.data;
  },

  createWallet: async (walletData: CreateWalletDTO): Promise<Wallet> => {
    const response = await apiClient.post<Wallet>(walletAPI.createWallet(), walletData);
    return response.data;
  },

  deposit: async (walletId: number, data: DepositWithdrawDTO): Promise<{ balance: number }> => {
    const response = await apiClient.post<{ balance: number }>(walletAPI.deposit(walletId), data);
    return response.data;
  },

  withdraw: async (walletId: number, data: DepositWithdrawDTO): Promise<{ balance: number }> => {
    const response = await apiClient.post<{ balance: number }>(walletAPI.withdraw(walletId), data);
    return response.data;
  },

  transfer: async (data: TransferDTO): Promise<{ fromBalance: number, toBalance: number }> => {
    const response = await apiClient.post<{ fromBalance: number, toBalance: number }>(walletAPI.transfer(), data);
    return response.data;
  },

  trade: async (data: TradeRequestDTO): Promise<TradeResponseDTO> => {
    const response = await apiClient.post<TradeResponseDTO>(walletAPI.trade(), data);
    return response.data;
  },

  // *** NOVA FUNÇÃO PARA HISTÓRICO (RF-09) ***
  getHistory: async (userId: number): Promise<WalletTransaction[]> => {
    // Rota: GET /wallet/history?userId=1
    // Nota: Certifique-se que esta rota está no ocelot.json apontando para /api/Wallet/history
    const response = await apiClient.get<WalletTransaction[]>(`/wallet/history?userId=${userId}`);
    return response.data;
  },
};

export default walletService;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\api\api.ts ====
// Caminho: frontend/src/shared/api/api.ts

const crudAPI = (basePath: string) => ({
  create: () => `${basePath}`,
  getAll: () => `${basePath}`,
  getById: (id: string | number) => `${basePath}/${id}`,
  update: (id: string | number) => `${basePath}/${id}`,
  delete: (id: string | number) => `${basePath}/${id}`,
});

// As rotas aqui DEVEM corresponder exatamente ao 'UpstreamPathTemplate' do ocelot.json
export const userAPI = crudAPI(`/user`);
export const currencyAPI = crudAPI(`/currency`);
export const authAPI = {
  login: () => `/auth/login`,
  getProfile: () => `/auth/profile`,
};

// Definições para a Wallet API
export const walletAPI = {
  // GET /wallet?userId={userId}
  getUserWallets: (userId: number) => `/wallet?userId=${userId}`,
  // POST /wallet
  createWallet: () => `/wallet`,
  // POST /wallet/{id}/deposit
  deposit: (walletId: number) => `/wallet/${walletId}/deposit`,
  // POST /wallet/{id}/withdraw
  withdraw: (walletId: number) => `/wallet/${walletId}/withdraw`,
  // POST /wallet/transfer (transferência simples)
  transfer: () => `/wallet/transfer`,

  // ****** NOVA ROTA ADICIONADA ******
  // POST /wallet/trade (troca/swap de moedas)
  trade: () => `/wallet/trade`,
  // **********************************
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\api\apiClient.ts ====
// Caminho: frontend/src/shared/api/apiClient.ts

import axios from 'axios';
// 1. Importar o store diretamente (NÃO o hook)
import { useAuthStore } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho se necessário

// 2. Definimos a URL base do seu Gateway API.
const API_BASE_URL = 'http://localhost:5026';

// 3. Criamos a instância do axios.
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 4. Interceptor de REQUISIÇÃO (Este você já tinha)
// Adiciona o token JWT em TODAS as requisições
apiClient.interceptors.request.use(
  (config) => {
    // Pega o token diretamente do store Zustand ou do localStorage
    // Usar o store é melhor caso o token seja atualizado em memória
    const token = useAuthStore.getState().token || (typeof window !== 'undefined' ? localStorage.getItem('token') : null);
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 5. NOVO: Interceptor de RESPOSTA (A Solução para o 401)
// Observa todas as respostas que chegam da API
apiClient.interceptors.response.use(
  (response) => {
    // Se a resposta for 2xx (Sucesso), apenas a repassa
    return response;
  },
  (error) => {
    // Se a API retornar um erro
    const { response } = error;

    // Verifica se o erro é um 401 (Não Autorizado / Token Expirado)
    if (response && response.status === 401) {
      console.warn("apiClient Interceptor: Erro 401 (Não Autorizado) detetado. Token expirado ou inválido. Executando logout...");

      // Pega a ação de logout DIRETAMENTE do store (não podemos usar hooks aqui)
      const { logout } = useAuthStore.getState().actions;
      
      // Chama a ação de logout
      // Isso limpará o token do localStorage e resetará o estado do Zustand
      logout();

      // Redireciona o usuário para a página de login
      if (typeof window !== 'undefined') {
        // Usamos replace para não adicionar a página "morta" ao histórico do navegador
        // Verificamos se já não estamos no login para evitar loops
        if (window.location.pathname !== '/login') {
          window.location.replace('/login?sessionExpired=true'); // Adiciona um parâmetro (opcional)
        }
      }
    }

    // Repassa o erro original para que a função que fez a chamada (ex: o handleSubmit)
    // ainda possa recebê-lo e tratar (ex: parar o loading, mostrar notificação)
    return Promise.reject(error);
  }
);

export default apiClient;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\AppLayout.tsx ====
// Caminho: frontend/src/shared/components/AppLayout.tsx

'use client';

import { useState, useEffect } from 'react'; // Removido useCallback
import {
    Box, Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText,
    Toolbar, useTheme, AppBar, IconButton, Typography, Avatar, Button,
    useMediaQuery, CircularProgress // Adicionado CircularProgress
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import PeopleIcon from '@mui/icons-material/People';
import MonetizationOnIcon from '@mui/icons-material/MonetizationOn';
import MenuIcon from '@mui/icons-material/Menu';
import { usePathname, useRouter } from 'next/navigation';

// 1. Importar os hooks do nosso authStore
import { useAuthStore, useAuthUser, useIsAuthenticated, useAuthLoading, useAuthActions } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho se necessário

const drawerWidth = 240;

const navItems = [
    { text: 'Dashboard', href: '/dashboard', icon: <DashboardIcon /> },
    { text: 'Usuários', href: '/users', icon: <PeopleIcon /> },
    { text: 'Moedas', href: '/currency', icon: <MonetizationOnIcon /> },
];

export const AppLayout = ({ children }: { children: React.ReactNode }) => {
    const theme = useTheme();
    const router = useRouter();
    const pathname = usePathname();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    const [mobileOpen, setMobileOpen] = useState(false);

    // 2. Usar o estado e as ações do store
    const { fetchProfile, logout } = useAuthActions();
    const user = useAuthUser(); // Contém { id, name, email }
    const isAuthenticated = useIsAuthenticated();
    const isLoadingAuth = useAuthLoading(); // Pega o estado de carregamento do store

    // 3. useEffect para buscar o perfil na montagem do componente
    useEffect(() => {
        console.log("AppLayout mounted, attempting to fetch profile...");
        fetchProfile(); // Chama a ação do store para verificar token e buscar perfil
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // Executa apenas uma vez na montagem

    // 4. useEffect para redirecionar se não autenticado APÓS o carregamento inicial
    useEffect(() => {
        // Só redireciona APÓS terminar a verificação inicial E se não estiver autenticado
        if (!isLoadingAuth && !isAuthenticated) {
            console.log("Not authenticated after loading, redirecting to login...");
            router.push('/login');
        }
    }, [isLoadingAuth, isAuthenticated, router]);

    const handleDrawerToggle = () => {
        setMobileOpen(!mobileOpen);
    };

    // 5. Exibir um loader centralizado durante a verificação inicial
    if (isLoadingAuth) {
        return (
            <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh', bgcolor: '#0B0B0B' }}>
                <CircularProgress color="primary" />
                <Typography sx={{ ml: 2, color: 'primary.main' }}>Verificando sessão...</Typography>
            </Box>
        );
    }

    // 6. Se terminou de carregar e NÃO está autenticado, não renderiza o layout (será redirecionado pelo useEffect)
    // Isso evita um flash rápido do layout antes do redirecionamento.
    if (!isAuthenticated) {
        return null; // Ou um loader menor se preferir, mas o useEffect já vai redirecionar
    }

    // ----- O RESTO DO JSX permanece quase igual, mas usando dados do store -----

    const drawerContent = (
        <div>
            <Toolbar />
            <Box sx={{ overflow: 'auto', p: 1 }}>
                <List>
                    {navItems.map((item) => (
                        <ListItem key={item.text} disablePadding>
                            <ListItemButton
                                selected={pathname === item.href}
                                onClick={() => {
                                    router.push(item.href);
                                    if (isMobile) handleDrawerToggle();
                                }}
                                sx={{
                                     borderRadius: 2,
                                     marginBottom: '4px',
                                     borderLeft: '4px solid transparent',
                                     '&.Mui-selected': {
                                       backgroundColor: 'rgba(240, 185, 11, 0.1)',
                                       borderLeft: `4px solid ${theme.palette.primary.main}`,
                                       '& .MuiListItemIcon-root, & .MuiListItemText-primary': {
                                         color: theme.palette.primary.main,
                                         fontWeight: '600',
                                       },
                                     },
                                     '&:hover': {
                                       backgroundColor: 'rgba(255, 255, 255, 0.05)',
                                     },
                                }}
                            >
                                <ListItemIcon sx={{ color: theme.palette.text.secondary }}>
                                    {item.icon}
                                </ListItemIcon>
                                <ListItemText primary={item.text} />
                            </ListItemButton>
                        </ListItem>
                    ))}
                </List>
            </Box>
        </div>
    );

    return (
        <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: '#0B0B0B' }}>
            <AppBar
                position="fixed"
                sx={{
                    zIndex: theme.zIndex.drawer + 1,
                    bgcolor: theme.palette.background.paper,
                    borderBottom: `1px solid ${theme.palette.divider}`,
                }}
                elevation={0}
            >
                <Toolbar sx={{ justifyContent: 'space-between' }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        {isMobile && (
                            <IconButton
                                color="primary"
                                aria-label="open drawer"
                                edge="start"
                                onClick={handleDrawerToggle}
                                sx={{ mr: 2 }}
                            >
                                <MenuIcon />
                            </IconButton>
                        )}
                        <Typography variant="h5" color="primary" fontWeight="bold">
                            AMS HoldCrypto
                        </Typography>
                    </Box>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar sx={{ bgcolor: 'primary.main', width: 32, height: 32, color: '#0B0B0B' }}>
                            {/* 7. Usa o nome do usuário do store */}
                            {user.name ? user.name.charAt(0) : '?'}
                        </Avatar>
                        <Typography sx={{ display: { xs: 'none', sm: 'block' } }}>
                            {/* 7. Usa o nome do usuário do store */}
                            Olá, {user.name || 'Usuário'}
                        </Typography>
                        {/* 8. Chama a ação de logout do store */}
                        <Button color="primary" variant="outlined" onClick={() => logout()} sx={{ fontWeight: 'bold' }}>
                            Sair
                        </Button>
                    </Box>
                </Toolbar>
            </AppBar>

            <Box
                component="nav"
                sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
            >
                <Drawer
                    variant={isMobile ? 'temporary' : 'permanent'}
                    open={isMobile ? mobileOpen : true}
                    onClose={handleDrawerToggle}
                    ModalProps={{ keepMounted: true }}
                    sx={{
                        '& .MuiDrawer-paper': {
                            boxSizing: 'border-box',
                            width: drawerWidth,
                            bgcolor: theme.palette.background.paper,
                            borderRight: { md: `1px solid ${theme.palette.divider}` },
                        },
                    }}
                >
                    {drawerContent}
                </Drawer>
            </Box>

            <Box component="main" sx={{ flexGrow: 1, p: 3, color: '#fff', width: { md: `calc(100% - ${drawerWidth}px)` } }}>
                <Toolbar />
                {/* Renderiza o conteúdo da página somente se autenticado */}
                {children}
            </Box>
        </Box>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\AuthInitializer.tsx ====
// Caminho: frontend/src/shared/components/AuthInitializer.tsx
'use client';

import { useEffect } from 'react';
import { useAuthActions } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho se necessário

// Este componente não renderiza nada visualmente,
// ele apenas executa a lógica de verificação de auth uma vez.
export function AuthInitializer({ children }: { children: React.ReactNode }) {
  const { fetchProfile } = useAuthActions();

  useEffect(() => {
    console.log("AuthInitializer: Running initial auth check...");
    fetchProfile();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Executa apenas uma vez quando o app carrega

  return <>{children}</>; // Renderiza os filhos normalmente
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\ChartBox.tsx ====
'use client';
import React, { useState } from 'react';
import { Box, Typography, Button, useTheme, Paper, ButtonGroup } from '@mui/material';
import { AreaChart, Area, XAxis, YAxis, Tooltip, ResponsiveContainer, Legend } from 'recharts';

// Tipagem para os dados do gráfico
type PeriodKey = 'week' | 'month' | 'year';
interface BalanceData {
  name: string;
  Balance: number;
  Income: number;
  Outcome: number;
}

// Dados simulados para diferentes períodos, focados em balanço
const chartData: Record<PeriodKey, BalanceData[]> = {
  week: [
    { name: 'Seg', Income: 400, Outcome: 240, Balance: 160 },
    { name: 'Ter', Income: 300, Outcome: 139, Balance: 161 },
    { name: 'Qua', Income: 200, Outcome: 980, Balance: -780 },
    { name: 'Qui', Income: 278, Outcome: 390, Balance: -112 },
    { name: 'Sex', Income: 189, Outcome: 480, Balance: -291 },
  ],
  month: [
    { name: 'Sem 1', Income: 1400, Outcome: 400, Balance: 1000 },
    { name: 'Sem 2', Income: 1500, Outcome: 1000, Balance: 500 },
    { name: 'Sem 3', Income: 1200, Outcome: 1800, Balance: -600 },
    { name: 'Sem 4', Income: 2000, Outcome: 500, Balance: 1500 },
  ],
  year: [
    { name: 'Jan', Income: 4000, Outcome: 2400, Balance: 1600 },
    { name: 'Fev', Income: 3000, Outcome: 1398, Balance: 1602 },
    { name: 'Mar', Income: 2000, Outcome: 9800, Balance: -7800 },
    { name: 'Abr', Income: 2780, Outcome: 3908, Balance: -1128 },
    { name: 'Mai', Income: 1890, Outcome: 4800, Balance: -2910 },
    { name: 'Jun', Income: 2390, Outcome: 3800, Balance: -1410 },
  ],
};

const periods: { label: string; key: PeriodKey }[] = [
  { label: "Semana", key: "week" },
  { label: "Mês", key: "month" },
  { label: "Ano", key: "year" },
];

export default function ChartBox() {
  const [selectedPeriod, setSelectedPeriod] = useState<PeriodKey>("year");
  const theme = useTheme();
  const data = chartData[selectedPeriod];

  return (
    <Paper 
        sx={{ 
            p: 3, 
            bgcolor: 'background.paper', 
            borderRadius: 4, 
            height: '100%',
            display: 'flex',
            flexDirection: 'column'
        }}
    >
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6" fontWeight="bold">
          Overview
        </Typography>
        <ButtonGroup variant="outlined" size="small">
            {periods.map((p) => (
                <Button
                    key={p.key}
                    onClick={() => setSelectedPeriod(p.key)}
                    sx={{
                        color: selectedPeriod === p.key ? '#0B0B0B' : 'primary.main',
                        backgroundColor: selectedPeriod === p.key ? 'primary.main' : 'transparent',
                        borderColor: 'primary.main',
                        '&:hover': {
                            backgroundColor: 'primary.main',
                            color: '#0B0B0B',
                            opacity: 0.9
                        }
                    }}
                >
                    {p.label}
                </Button>
            ))}
        </ButtonGroup>
      </Box>
      <Box flex={1} minHeight={300}>
        <ResponsiveContainer width="100%" height="100%">
          <AreaChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
             <defs>
                <linearGradient id="colorBalance" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor={theme.palette.primary.main} stopOpacity={0.8}/>
                <stop offset="95%" stopColor={theme.palette.primary.main} stopOpacity={0}/>
                </linearGradient>
            </defs>
            <XAxis dataKey="name" stroke={theme.palette.text.secondary} fontSize={12} />
            <YAxis stroke={theme.palette.text.secondary} fontSize={12} />
            <Tooltip
              contentStyle={{ 
                  backgroundColor: 'rgba(30, 30, 30, 0.8)', 
                  borderColor: theme.palette.divider,
                  borderRadius: theme.shape.borderRadius
              }}
              labelStyle={{ color: theme.palette.primary.main, fontWeight: 'bold' }}
            />
            <Legend wrapperStyle={{ fontSize: '14px' }} />
            <Area 
                type="monotone" 
                dataKey="Balance" 
                stroke={theme.palette.primary.main} 
                strokeWidth={2}
                fillOpacity={1} 
                fill="url(#colorBalance)" 
            />
          </AreaChart>
        </ResponsiveContainer>
      </Box>
    </Paper>
  );
}



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\CoinHighlight.tsx ====
'use client';
import React from 'react';
import { Box, Typography, Paper, Avatar, useTheme } from '@mui/material';

export interface CoinHighlightProps {
  name: string;
  symbol: string;
  price: number;
  change: number;
}

// 1. Adicionamos a mesma função de formatação da Dashboard aqui
const formatCurrencyValue = (value: number) => {
    if (value >= 1_000_000_000) return `${(value / 1_000_000_000).toFixed(2)}B`;
    if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(2)}M`;
    if (value >= 1_000) return `${(value / 1_000).toFixed(2)}K`;
    // Para valores menores, usamos a formatação completa para precisão
    return value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
};

const getSymbolColor = (symbol: string) => {
  const colors = ['#F0B90B', '#627EEA', '#26A17B', '#F3BA2F', '#8A2BE2', '#4F4F4F', '#f0f0f0'];
  let hash = 0;
  for (let i = 0; i < symbol.length; i++) {
    hash = symbol.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
};

const CoinHighlight: React.FC<CoinHighlightProps> = ({ name, symbol, price, change }) => {
  const theme = useTheme();
  const isPositive = change >= 0;

  return (
    <Paper
      sx={{
        p: 3,
        bgcolor: 'background.paper',
        borderRadius: 4,
        border: `1px solid ${theme.palette.divider}`,
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        transition: 'transform 0.2s, box-shadow 0.2s',
        '&:hover': {
          transform: 'translateY(-4px)',
          boxShadow: `0 8px 24px ${theme.palette.primary.main}20`,
        },
      }}
    >
      <Box display="flex" alignItems="center" mb={2}>
        <Avatar sx={{ bgcolor: getSymbolColor(symbol), width: 40, height: 40, mr: 2, color: '#0B0B0B', fontWeight: 'bold' }}>
          {symbol.charAt(0)}
        </Avatar>
        <Box>
          <Typography variant="h6" fontWeight="bold">
            {name}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {symbol}
          </Typography>
        </Box>
      </Box>
      <Box>
        <Typography variant="h5" fontWeight="bold" textAlign="right">
          {/* 2. Aplicamos a formatação aqui */}
          R$ {formatCurrencyValue(price)}
        </Typography>
        <Typography
          textAlign="right"
          fontWeight="bold"
          sx={{ color: isPositive ? theme.palette.success.main : theme.palette.error.main }}
        >
          {isPositive ? '?' : '?'} {Math.abs(change).toFixed(2)}%
        </Typography>
      </Box>
    </Paper>
  );
};

export default CoinHighlight;



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\Footer.tsx ====
'use client';
import React from 'react';
import Box from "@mui/material/Box";
import Container from "@mui/material/Container";
import Grid from "@mui/material/Grid";
import Typography from "@mui/material/Typography";
import Link from 'next/link';
import { useTheme } from "@mui/material/styles";

const footerLinks = [
  { text: 'Home', href: '/' },
  { text: 'Moedas', href: '/currency' },
  { text: 'Login', href: '/login' },
];

export default function Footer() {
  const theme = useTheme();
  return (
    <Box
      component="footer"
      sx={{
        bgcolor: theme.palette.background.paper, // Um cinza escuro, #1E1E1E
        color: theme.palette.text.secondary,
        py: 6,
        borderTop: `1px solid ${theme.palette.divider}`,
      }}
    >
      <Container maxWidth="lg">
        <Grid container spacing={5}>
          {/* Coluna da Esquerda: Branding */}
          <Grid item xs={12} md={6}>
            <Typography variant="h5" color="primary" fontWeight="bold" gutterBottom>
              AMS HoldCrypto
            </Typography>
            <Typography variant="body2" sx={{ pr: { md: 5 } }}>
              Sua plataforma completa para acompanhar, negociar e aprender sobre o universo das criptomoedas. Oferecemos ferramentas de ponta para suas decisões financeiras.
            </Typography>
          </Grid>

          {/* Coluna da Direita: Links Rápidos */}
          <Grid item xs={12} md={6}>
            <Typography variant="h6" color="white" fontWeight="bold" gutterBottom>
              Navegação
            </Typography>
            <Box component="ul" sx={{ listStyle: 'none', p: 0, m: 0 }}>
              {footerLinks.map((link) => (
                <Box component="li" key={link.text} sx={{ mb: 1 }}>
                  <Typography
                    component={Link}
                    href={link.href}
                    sx={{
                      color: 'text.secondary',
                      textDecoration: 'none',
                      '&:hover': {
                        color: 'primary.main',
                        textDecoration: 'underline',
                      },
                    }}
                  >
                    {link.text}
                  </Typography>
                </Box>
              ))}
            </Box>
          </Grid>
        </Grid>
        
        {/* Barra de Copyright */}
        <Box
          sx={{
            mt: 6,
            pt: 3,
            borderTop: `1px solid ${theme.palette.divider}`,
            textAlign: 'center',
          }}
        >
          <Typography variant="body2">
            &copy; {new Date().getFullYear()} AMS Trade Holding. Todos os direitos reservados.
          </Typography>
        </Box>
      </Container>
    </Box>
  );
}



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\Header.tsx ====


'use client';
import React, { useState } from "react"; // Removido useEffect
import { useRouter } from "next/navigation";
import Link from "next/link";
import {
    AppBar, Toolbar, Typography, Button, Box, IconButton,
    Menu, MenuItem, Avatar, useTheme
} from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";

// 1. Importar hooks do store (NÃO importar authService diretamente)
import { useAuthUser, useIsAuthenticated, useAuthActions } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho

export default function Header() {
    const router = useRouter();
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const theme = useTheme();

    // 2. Usar estado e ações do store
    const user = useAuthUser(); // { id, name, email }
    const isAuthenticated = useIsAuthenticated();
    const { logout } = useAuthActions();

    // 3. REMOVIDO: useEffect para checkAuthStatus - O AppLayout ou a inicialização do app agora cuidam disso.
    // Este header apenas reflete o estado atual do store.

    // 4. Simplificado: handleLogout agora chama a ação do store
    const handleLogout = () => {
        logout(); // Chama a ação do store que limpa state e localStorage
        router.push("/login"); // Redireciona após logout
    };

    const handleMenu = (event: React.MouseEvent<HTMLElement>) => {
        setAnchorEl(event.currentTarget);
    };
    const handleClose = () => {
        setAnchorEl(null);
    };

    return (
        <AppBar
            position="sticky"
            color="default"
            elevation={1}
            sx={{
                bgcolor: theme.palette.background.paper,
                borderBottom: `1px solid ${theme.palette.divider}`,
            }}
        >
            <Toolbar sx={{ justifyContent: 'space-between', py: 1 }}>
                <Link href="/" style={{ textDecoration: "none" }}>
                    <Typography
                        variant="h5"
                        color="primary"
                        fontWeight="bold"
                        sx={{ letterSpacing: 1.5, cursor: "pointer" }}
                    >
                        AMS HoldCrypto
                    </Typography>
                </Link>

                {/* Menu para telas pequenas */}
                <Box sx={{ display: { xs: "flex", md: "none" } }}>
                    <IconButton color="primary" onClick={handleMenu}>
                        <MenuIcon />
                    </IconButton>
                    <Menu
                        anchorEl={anchorEl}
                        open={Boolean(anchorEl)}
                        onClose={handleClose}
                        PaperProps={{
                            sx: {
                                bgcolor: theme.palette.background.paper,
                                border: `1px solid ${theme.palette.divider}`,
                            },
                        }}
                    >
                        {/* 5. Usa isAuthenticated e user.name do store */}
                        {isAuthenticated ? (
                            [
                                <MenuItem key="user" disabled sx={{ opacity: 1 }}>Olá, {user.name || 'Usuário'}</MenuItem>,
                                <MenuItem key="logout" onClick={handleLogout}>Sair</MenuItem> // Chama handleLogout
                            ]
                        ) : (
                            [
                                <MenuItem key="login" onClick={() => router.push("/login")}>Login</MenuItem>,
                                <MenuItem key="register" onClick={() => router.push("/register")}>Registrar-se</MenuItem>
                            ]
                        )}
                    </Menu>
                </Box>

                {/* Menu para telas médias/grandes */}
                <Box sx={{ display: { xs: "none", md: "flex" }, alignItems: "center", gap: 2 }}>
                     {/* 5. Usa isAuthenticated e user.name do store */}
                    {isAuthenticated ? (
                        <>
                            <Avatar sx={{ bgcolor: 'primary.main', width: 32, height: 32, color: '#0B0B0B', fontWeight: 'bold' }}>
                                {user.name ? user.name.charAt(0) : '?'}
                            </Avatar>
                            <Typography color="text.primary" fontWeight="500">
                                Olá, {user.name || 'Usuário'}
                            </Typography>
                            <Button
                                color="primary"
                                variant="outlined"
                                onClick={handleLogout} // Chama handleLogout
                                sx={{ fontWeight: "bold", borderWidth: 2 }}
                            >
                                Sair
                            </Button>
                        </>
                    ) : (
                        <>
                            <Button
                                color="primary"
                                variant="text"
                                component={Link}
                                href="/login"
                                sx={{ fontWeight: "bold" }}
                            >
                                Sign In
                            </Button>
                            <Button
                                color="primary"
                                variant="contained"
                                component={Link}
                                href="/register"
                                sx={{ fontWeight: "bold" }}
                            >
                                Sign Up
                            </Button>
                        </>
                    )}
                </Box>
            </Toolbar>
        </AppBar>
    );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\MainButton.tsx ====
'use client';
import React from "react";
import clsx from "clsx";

// 1. A interface de props agora inclui 'children' explicitamente.
interface MainButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary";
  children: React.ReactNode; // Diz ao TypeScript que este componente recebe conteúdo.
}

// 2. A função agora recebe 'children' e o renderiza dentro do botão.
const MainButton: React.FC<MainButtonProps> = ({ variant = "primary", className, children, ...props }) => {
  return (
    <button
      className={clsx(
        "px-10 py-4 rounded-lg shadow-md transition-all duration-300 font-semibold focus:ring-4 text-base sm:text-lg",
        variant === "primary"
          ? "bg-yellow-500 hover:bg-yellow-400 text-black focus:ring-yellow-300"
          : "bg-neutral-900 hover:bg-gray-800 text-yellow-400 focus:ring-gray-600",
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
};

export default MainButton;


---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\Modal.tsx ====
"use client";
import React from 'react';
import { Modal as MuiModal, Box, IconButton, Typography, Backdrop } from '@mui/material';
import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'lucide-react';

interface ModalProps {
  open: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

const modalVariants = {
  hidden: { opacity: 0, scale: 0.95, y: -20 },
  visible: { opacity: 1, scale: 1, y: 0 },
  exit: { opacity: 0, scale: 0.95, y: 20 },
};

const Modal: React.FC<ModalProps> = ({ open, onClose, title, children }) => {
  return (
    <AnimatePresence>
      {open && (
        <MuiModal
          open={open}
          onClose={onClose}
          closeAfterTransition
          slots={{ backdrop: Backdrop }}
          slotProps={{
            backdrop: {
              timeout: 500,
            },
          }}
        >
          <motion.div
            variants={modalVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
          >
            <Box
              sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: { xs: '90%', sm: 500 },
                bgcolor: '#1E1E1E',
                border: '1px solid #333',
                borderRadius: 4,
                boxShadow: 24,
                display: 'flex',
                flexDirection: 'column',
              }}
            >
              {/* Modal Header */}
              <Box sx={{ p: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '1px solid #333' }}>
                <Typography variant="h6" component="h2" fontWeight="bold">
                  {title}
                </Typography>
                <IconButton onClick={onClose}>
                  <X size={20} />
                </IconButton>
              </Box>

              {/* Modal Content */}
              <Box sx={{ p: 3, overflowY: 'auto' }}>
                {children}
              </Box>
            </Box>
          </motion.div>
        </MuiModal>
      )}
    </AnimatePresence>
  );
};

export default Modal;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\NewsSection.tsx ====
'use client';
import React from 'react';
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import Container from '@mui/material/Container';
import Grid from '@mui/material/Grid';
import Paper from '@mui/material/Paper';
import { useTheme } from '@mui/material/styles';

// Mantendo seus dados de notícias originais
const news = [
  {
    title: "Bitcoin atinge novo topo em 2025!",
    desc: "O mercado segue aquecido com alta demanda institucional."
  },
  {
    title: "Ethereum lança atualização Shanghai",
    desc: "Prometendo taxas menores e mais escalabilidade."
  },
  {
    title: "BNB Chain cresce em volume",
    desc: "Novos projetos DeFi impulsionam a rede."
  }
];

const NewsSection: React.FC = () => {
  const theme = useTheme();
  return (
    <Box
      sx={{
        py: { xs: 6, md: 10 },
        bgcolor: theme.palette.background.default, // Fundo principal escuro
      }}
      component="section"
    >
      <Container maxWidth="lg">
        <Typography 
          variant="h3" 
          component="h2" 
          textAlign="center" 
          fontWeight="bold" 
          sx={{ mb: 6 }}
        >
          Fique por Dentro das <span style={{ color: theme.palette.primary.main }}>Últimas Notícias</span>
        </Typography>
        <Grid container spacing={4}>
          {news.map((item, i) => (
            <Grid item xs={12} md={4} key={i}>
              <Paper
                elevation={0}
                sx={{
                  p: 3,
                  bgcolor: theme.palette.background.paper,
                  border: `1px solid ${theme.palette.divider}`,
                  borderRadius: 4,
                  height: '100%',
                }}
              >
                <Typography variant="h6" component="h3" fontWeight="bold" color="primary.main" gutterBottom>
                  {item.title}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {item.desc}
                </Typography>
              </Paper>
            </Grid>
          ))}
        </Grid>
      </Container>
    </Box>
  );
};

export default NewsSection;



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\components\NotificationToast.tsx ====
"use client";

import React from 'react';
import { motion } from 'framer-motion';
import { Alert, AlertTitle, IconButton, Box } from '@mui/material';
import { CheckCircle, XCircle, X } from 'lucide-react';

export type NotificationType = 'success' | 'error';

interface NotificationToastProps {
  message: string;
  type: NotificationType;
  onClose: () => void;
}

const toastVariants = {
  hidden: { opacity: 0, x: 100 },
  visible: { opacity: 1, x: 0 },
  exit: { opacity: 0, x: 100 },
};

const icons = {
  success: <CheckCircle color="currentColor" />,
  error: <XCircle color="currentColor" />,
};

const NotificationToast: React.FC<NotificationToastProps> = ({ message, type, onClose }) => {
  const title = type === 'success' ? 'Sucesso' : 'Erro';

  return (
    <motion.div
      variants={toastVariants}
      initial="hidden"
      animate="visible"
      exit="exit"
      layout
    >
      <Alert
        severity={type}
        icon={icons[type]}
        action={
          <IconButton color="inherit" size="small" onClick={onClose}>
            <X size={18} />
          </IconButton>
        }
        sx={{
          width: '100%',
          boxShadow: 6,
          borderRadius: 2,
          '& .MuiAlert-icon': {
            alignItems: 'center',
          },
        }}
      >
        <AlertTitle sx={{ fontWeight: 'bold' }}>{title}</AlertTitle>
        {message}
      </Alert>
    </motion.div>
  );
};

export default NotificationToast;

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\context\NotificationContext.tsx ====
"use client";

import React, { createContext, useContext, useState, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import { Box } from '@mui/material';
import NotificationToast, { NotificationType } from '@/shared/components/NotificationToast';

interface Notification {
  id: number;
  message: string;
  type: NotificationType;
}

interface NotificationContextType {
  showNotification: (message: string, type: NotificationType) => void;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

export const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [notifications, setNotifications] = useState<Notification[]>([]);

  const removeNotification = useCallback((id: number) => {
    setNotifications((prev) => prev.filter((n) => n.id !== id));
  }, []);

  const showNotification = useCallback((message: string, type: NotificationType) => {
    const newNotification = {
      id: Date.now(),
      message,
      type,
    };
    setNotifications((prev) => [...prev, newNotification]);

    setTimeout(() => {
      removeNotification(newNotification.id);
    }, 5000); // A notificação desaparecerá após 5 segundos
  }, [removeNotification]);

  return (
    <NotificationContext.Provider value={{ showNotification }}>
      {children}
      <Box
        sx={{
          position: 'fixed',
          top: 80, // Abaixo do Header
          right: 16,
          zIndex: 1500, // Acima de outros elementos
          display: 'flex',
          flexDirection: 'column',
          gap: 1,
        }}
      >
        <AnimatePresence>
          {notifications.map((notification) => (
            <NotificationToast
              key={notification.id}
              message={notification.message}
              type={notification.type}
              onClose={() => removeNotification(notification.id)}
            />
          ))}
        </AnimatePresence>
      </Box>
    </NotificationContext.Provider>
  );
};

// Hook customizado para usar o contexto
export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (context === undefined) {
    throw new Error('useNotification must be used within a NotificationProvider');
  }
  return context;
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\theme\boxStyles.ts ====
export const yellowBorderBox = {
  borderRadius: "32px",
  border: "3px solid #fcd34d",
  background: "#18181b",
  color: "#fff",
  p: 3,
  boxShadow: 2,
};

export const authFormBox = {
  width: "100%",
  bgcolor: "#18181b",
  borderRadius: "32px",
  border: "3px solid #fcd34d",
  boxShadow: 4,
  p: { xs: 3, sm: 6 },
  color: "#fff",
  mt: 8,
};

export const crudTableBox = {
  borderRadius: "24px",
  border: "2px solid #fcd34d",
  background: "#23272f",
  color: "#fff",
  p: 3,
  boxShadow: 1,
  mt: 4,
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\theme\fieldStyles.ts ====
export const yellowField = {
  input: { color: "#fff", bgcolor: "#23272f", borderRadius: 2 },
  label: { color: "#fcd34d" },
  "& .MuiOutlinedInput-root": {
    "& fieldset": { borderColor: "#fcd34d" },
    "&:hover fieldset": { borderColor: "#ffe066" },
    "&.Mui-focused fieldset": { borderColor: "#fcd34d" },
  },
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\theme\theme.ts ====
import { createTheme } from "@mui/material/styles";
import { Inter } from "next/font/google";

export const inter = Inter({
  weight: ['300', '400', '500', '700'],
  subsets: ['latin'],
  display: 'swap',
});

// Este é o nosso novo tema centralizado, a "constituição" do design.
const theme = createTheme({
  palette: {
    mode: "dark",
    primary: { main: "#F0B90B" }, // Amarelo principal
    secondary: { main: "#ffe066" }, // Amarelo mais claro para hovers
    background: { 
      default: "#0B0B0B", // Preto profundo para fundos de página
      paper: "#1E1E1E"    // Cinza escuro para cards e elementos elevados
    },
    text: { 
      primary: "#FFFFFF",
      secondary: "#b0b0b0" 
    },
    divider: "#333333",
    success: { main: "#22c55e" },
    error: { main: "#ef4444" },
  },
  typography: {
    fontFamily: inter.style.fontFamily,
    h1: { fontWeight: 700 },
    h2: { fontWeight: 700 },
    h3: { fontWeight: 700 },
    h4: { fontWeight: 700 },
    h5: { fontWeight: 600 },
    h6: { fontWeight: 600 },
  },
  shape: {
    borderRadius: 12,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          fontWeight: "bold",
          textTransform: 'none',
          borderRadius: 8,
          padding: '10px 24px',
        },
        containedPrimary: {
          color: "#0B0B0B",
          '&:hover': {
            backgroundColor: "#ffe066",
          }
        },
      },
    },
    MuiPaper: {
        styleOverrides: {
            root: {
                backgroundImage: 'none', // Remove gradientes padrão do MUI em modo dark
            }
        }
    },
    MuiTextField: {
        styleOverrides: {
            root: {
                '& label.Mui-focused': {
                    color: '#F0B90B',
                },
                '& .MuiOutlinedInput-root': {
                    '& fieldset': {
                        borderColor: '#333333',
                    },
                    '&:hover fieldset': {
                        borderColor: '#F0B90B',
                    },
                    '&.Mui-focused fieldset': {
                        borderColor: '#F0B90B',
                    },
                },
            }
        }
    }
  },
});

export default theme;



---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\shared\theme\ThemeProvider.tsx ====
// Caminho: frontend/src/shared/theme/ThemeProvider.tsx

'use client';
import { ThemeProvider as MuiThemeProvider, CssBaseline } from '@mui/material';
// Usando o caminho relativo para garantir que funcione
import theme from './theme'; 

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <MuiThemeProvider theme={theme}>
      <CssBaseline />
      {children}
    </MuiThemeProvider>
  );
}

---- end of file ----

