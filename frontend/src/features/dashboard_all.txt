==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\HotList.tsx ====
'use client';
import { Box, Typography, Stack, Avatar } from '@mui/material';
import { useDashboardStore } from '../store/DashboardStore';
import { Currency, History } from '@/features/currency/types/Currency';
import { TrendingUp, TrendingDown } from 'lucide-react';
import CoinIcon from '@/features/currency/components/CoinIcon'; // Importe o CoinIcon

const formatPrice = (price: number) => {
    return price.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', maximumFractionDigits: 2 });
};

// Lógica de cálculo UNIFICADA com o gráfico (Importante!)
const calculateTrend = (histories: History[] | undefined) => {
    if (!histories || histories.length < 2) return 0;

    // Ordena do mais antigo [0] para o mais recente [length-1]
    const sorted = [...histories].sort((a, b) => 
        new Date(a.datetime).getTime() - new Date(b.datetime).getTime()
    );

    const priceStart = sorted[0].price; // Preço inicial
    const priceNow = sorted[sorted.length - 1].price; // Preço final
    
    if (priceStart === 0) return 0;
    return ((priceNow - priceStart) / priceStart) * 100;
};

const HotListItem = ({ coin, isSelected, onSelect }: { coin: Currency, isSelected: boolean, onSelect: () => void }) => {
    const change = calculateTrend(coin.histories);
    const isPositive = change >= 0;
    
    // Pega o preço mais recente
    const latestPrice = coin.histories && coin.histories.length > 0 
        ? coin.histories.sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime())[0].price 
        : 0;

    return (
        <div 
            onClick={onSelect}
            className={`flex items-center justify-between p-3 rounded-xl cursor-pointer transition-all duration-200 group border
                ${isSelected 
                    ? 'bg-yellow-500/10 border-yellow-500/50 shadow-[0_0_15px_rgba(240,185,11,0.1)]' 
                    : 'bg-transparent border-transparent hover:bg-white/5 hover:border-white/5'
                }`}
        >
            <div className="flex items-center gap-3">
                {/* ÍCONE */}
                <div className="w-9 h-9 flex items-center justify-center">
                    <CoinIcon symbol={coin.symbol} name={coin.name} size={36} />
                </div>

                <div>
                    <p className={`font-bold text-sm transition-colors ${isSelected ? 'text-white' : 'text-gray-200 group-hover:text-yellow-500'}`}>
                        {coin.symbol}
                    </p>
                    <p className="text-xs text-gray-500">{coin.name}</p>
                </div>
            </div>
            
            <div className="text-right">
                <p className="font-mono text-sm font-medium text-white">{formatPrice(latestPrice)}</p>
                <div className={`flex items-center justify-end gap-1 text-xs font-bold ${isPositive ? 'text-emerald-400' : 'text-rose-400'}`}>
                    {isPositive ? <TrendingUp size={12} /> : <TrendingDown size={12} />}
                    {Math.abs(change).toFixed(2)}%
                </div>
            </div>
        </div>
    );
};

export const HotList = () => {
    const { currencies, selectedCoin, setSelectedCoin } = useDashboardStore();

    return (
        <div className="glass-panel p-5 rounded-3xl h-full border border-white/5">
            <div className="flex items-center justify-between mb-4 px-2">
                <h3 className="text-sm font-bold text-gray-400 uppercase tracking-wider flex items-center gap-2">
                    <TrendingUp size={14} /> Tendências
                </h3>
                <h3 className="text-xs font-bold text-gray-500 uppercase tracking-wider bg-white/5 px-2 py-1 rounded">
                    Global
                </h3>
            </div>
            <Stack spacing={1}>
                {currencies.slice(0, 6).map((coin) => (
                    <HotListItem 
                        key={coin.id ?? coin.symbol} 
                        coin={coin}
                        isSelected={selectedCoin?.id === coin.id}
                        onSelect={() => setSelectedCoin(coin)}
                    />
                ))}
            </Stack>
        </div>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\OverviewChart.tsx ====
'use client';
import { useMemo } from 'react';
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid, ReferenceLine } from 'recharts';
import { useDashboardSelectedCoin } from '../store/DashboardStore';
import { TrendingUp, TrendingDown, Minus } from 'lucide-react';

const formatChartValue = (value: number) => {
  if (value >= 1000) return `${(value / 1000).toFixed(1)}k`;
  return value.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
};

const CustomTooltip = ({ active, payload, label, color }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-[#0f172a]/95 backdrop-blur-xl border border-white/10 p-3 rounded-lg shadow-xl min-w-[140px]">
        <p className="text-gray-400 text-[10px] font-mono mb-1 uppercase tracking-wide">{label}</p>
        <div className="flex items-center gap-2">
            <span className="w-1 h-8 rounded-full" style={{ backgroundColor: color }}></span>
            <div>
                <p className="text-white text-sm font-bold font-mono">
                R$ {payload[0].value.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 8 })}
                </p>
            </div>
        </div>
      </div>
    );
  }
  return null;
};

export const OverviewChart = () => {
  const selectedCoin = useDashboardSelectedCoin();

  // 1. Preparação dos Dados
  const chartData = useMemo(() => {
    if (!selectedCoin?.histories || selectedCoin.histories.length === 0) return [];
    
    // a) Ordena TUDO cronologicamente primeiro
    const sortedAll = [...selectedCoin.histories].sort((a, b) => 
        new Date(a.datetime).getTime() - new Date(b.datetime).getTime()
    );

    // b) FILTRAGEM DE SEGURANÇA (A Mágica acontece aqui!)
    // Pegamos apenas os últimos 50 registros OU as últimas 24h.
    // Isso remove os preços "trilionários" antigos que estragam a escala.
    const recentHistory = sortedAll.slice(-50); // Pega os últimos 50

    return recentHistory.map(h => ({
        name: new Date(h.datetime).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),
        price: Number(h.price),
    }));
  }, [selectedCoin]);

  // 2. Lógica de Tendência
  const { chartColor, isPositive, startPrice, endPrice, percentageChange } = useMemo(() => {
    if (!chartData || chartData.length < 2) {
        return { chartColor: '#F0B90B', isPositive: true, startPrice: 0, endPrice: 0, percentageChange: 0 };
    }
    
    const start = chartData[0].price;
    const end = chartData[chartData.length - 1].price;
    const isPos = end >= start;
    
    // Verde (#22c55e) ou Vermelho (#ef4444)
    const color = isPos ? '#22c55e' : '#ef4444';
    
    const percent = start === 0 ? 0 : ((end - start) / start) * 100;

    return { 
        chartColor: color, 
        isPositive: isPos, 
        startPrice: start, 
        endPrice: end,
        percentageChange: percent
    };
  }, [chartData]);

  const TrendIcon = isPositive ? TrendingUp : TrendingDown;

  if (!chartData || chartData.length === 0) {
      return (
        <div className="glass-panel p-6 rounded-3xl h-[400px] flex flex-col items-center justify-center text-center border border-white/5">
            <div className="w-16 h-16 bg-white/5 rounded-full flex items-center justify-center mb-4">
                <Minus className="text-gray-600" size={32} />
            </div>
            <h3 className="text-gray-300 font-bold mb-1">Aguardando dados</h3>
            <p className="text-gray-600 text-sm">Sem histórico recente.</p>
        </div>
      )
  }

  return (
    <div className="glass-panel p-6 rounded-3xl border border-white/5 relative overflow-hidden group">
         
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8 gap-4">
        
        {/* Info Moeda */}
        <div className="flex items-center gap-4">
            <div className="w-12 h-12 rounded-2xl flex items-center justify-center text-black font-bold text-xl shadow-lg transition-colors duration-500"
                 style={{ backgroundColor: chartColor, boxShadow: `0 0 30px ${chartColor}30` }}>
                {selectedCoin?.symbol?.[0] || '$'}
            </div>
            <div>
                <div className="flex items-center gap-2">
                    <h3 className="text-xl font-bold text-white leading-tight">
                        {selectedCoin?.name || 'Mercado'}
                    </h3>
                    <span className="text-xs font-bold px-2 py-0.5 rounded text-black bg-white/80">
                        {selectedCoin?.symbol}
                    </span>
                </div>
                <div className="flex items-center gap-2 mt-1">
                    <span className="text-sm font-bold flex items-center gap-1" style={{ color: chartColor }}>
                        {isPositive ? '+' : ''}{percentageChange.toFixed(2)}%
                        <TrendIcon size={14} />
                    </span>
                    <span className="text-xs text-gray-500">vs. início do gráfico</span>
                </div>
            </div>
        </div>
        
        {/* Preço Atual */}
        <div className="text-right">
             <p className="text-3xl font-bold font-mono text-white tracking-tight drop-shadow-lg">
                R$ {endPrice.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 8 })}
             </p>
             <div className="flex items-center justify-end gap-2 text-xs text-gray-400 mt-1">
                <span className={`w-2 h-2 rounded-full animate-pulse`} style={{ backgroundColor: chartColor }}></span>
                Ao vivo
             </div>
        </div>
      </div>

      {/* Gráfico */}
      <div className="h-[350px] w-full -ml-2">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={chartData} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
            <CartesianGrid strokeDasharray="3 3" stroke="#ffffff08" vertical={false} />
            <XAxis dataKey="name" stroke="#525252" fontSize={10} tickLine={false} axisLine={false} tickMargin={15} minTickGap={40} />
            <YAxis stroke="#525252" fontSize={10} tickLine={false} axisLine={false} tickFormatter={formatChartValue} domain={['auto', 'auto']} orientation="right" />
            <Tooltip content={<CustomTooltip color={chartColor} />} cursor={{ stroke: '#ffffff20', strokeWidth: 1 }} />
            <ReferenceLine y={startPrice} stroke="#ffffff20" strokeDasharray="3 3" />
            <Line type="monotone" dataKey="price" stroke={chartColor} strokeWidth={3} dot={false} activeDot={{ r: 6, strokeWidth: 3, fill: '#0f172a', stroke: chartColor }} animationDuration={1000} />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\StatCard.tsx ====
'use client';
import { Box, Typography } from '@mui/material';
import { LucideIcon, ArrowUpRight, ArrowDownRight } from 'lucide-react';

interface StatCardProps {
  title: string;
  value: string;
  change?: number;
  Icon: LucideIcon;
}

export const StatCard = ({ title, value, change, Icon }: StatCardProps) => {
  const isPositive = change !== undefined && change >= 0;

  return (
    <div className="glass-panel p-5 rounded-2xl h-full flex flex-col justify-between relative overflow-hidden group hover:border-yellow-500/30 transition-all duration-300">
      {/* Background Glow Effect */}
      <div className="absolute -top-10 -right-10 w-24 h-24 bg-yellow-500/5 rounded-full blur-2xl group-hover:bg-yellow-500/10 transition-all"></div>

      <div className="flex justify-between items-start mb-4">
        <div className="p-2.5 rounded-xl bg-white/5 border border-white/5 text-gray-300">
            <Icon size={22} />
        </div>
        
        {change !== undefined && (
          <div className={`flex items-center gap-1 px-2 py-1 rounded-lg text-xs font-bold ${
            isPositive ? 'bg-emerald-500/10 text-emerald-400' : 'bg-rose-500/10 text-rose-400'
          }`}>
            {isPositive ? <ArrowUpRight size={14} /> : <ArrowDownRight size={14} />}
            {Math.abs(change).toFixed(2)}%
          </div>
        )}
      </div>

      <div>
        <Typography variant="body2" className="text-gray-400 font-medium mb-1">
          {title}
        </Typography>
        <Typography variant="h5" className="text-white font-bold tracking-tight font-mono">
          {value}
        </Typography>
      </div>
    </div>
  );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\StatsCards.tsx ====
// Caminho: frontend/src/features/dashboard/components/StatsCards.tsx
'use client';
import { Grid, Box, Typography } from '@mui/material';
import { StatCard } from './StatCard';
import { Wallet, TrendingUp, TrendingDown, Award } from 'lucide-react';
import { motion } from 'framer-motion';
import { useDashboardWallets, useDashboardCurrencies } from '../store/DashboardStore';
import { useMemo } from 'react';

// --- NOVA FUNÇÃO formatCurrencyValue ---
const formatCurrencyValue = (value: number | undefined | null): string => {
    const numericValue = Number(value);
    if (isNaN(numericValue) || value === undefined || value === null) {
        return "R$ --";
    }

    const prefix = "R$ ";
    
    // Lógica de Abreviação
    if (numericValue >= 1_000_000_000_000) { // Trilhão (T)
        return prefix + (numericValue / 1_000_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " T";
    }
    if (numericValue >= 1_000_000_000) { // Bilhão (B)
        return prefix + (numericValue / 1_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " B";
    }
    if (numericValue >= 1_000_000) { // Milhão (M)
        return prefix + (numericValue / 1_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " M";
    }
    if (numericValue >= 1_000) { // Mil (K)
        return prefix + (numericValue / 1_000).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + " K";
    }
    
    // Para valores menores, usa a formatação padrão completa
    return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2, maximumFractionDigits: 2 });
};
// ------------------------------------

const formatPercentValue = (value: number | undefined | null): number | undefined => {
    // ... (função mantida) ...
    if (value === undefined || value === null || isNaN(value)) {
        return undefined;
    }
    return value;
};

// --- Variantes de Animação (Mantidas) ---
const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.1 } } };
const itemVariants = { hidden: { y: 20, opacity: 0 }, visible: { y: 0, opacity: 1 } };

export const StatsCards = () => {
    const wallets = useDashboardWallets();
    const currencies = useDashboardCurrencies();

    // Lógica de cálculo (mantida)
    const calculatedStats = useMemo(() => {
        // ... (cálculo do twentyFourHoursAgo) ...
        const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).getTime();
        const priceDataMap = new Map<string, { now: number, twentyFourHoursAgoPrice: number | null, change: number }>();
        let bestPerformer = { symbol: '---', change: -Infinity };

        for (const currency of currencies) {
            // ... (lógica de ordenação e busca de preço) ...
            if (!currency.histories || currency.histories.length === 0 || !currency.symbol) continue;
            const sortedHistories = [...currency.histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime());
            const priceNow = sortedHistories[0]?.price;
            if (!priceNow) continue;

            let price24hAgo: number | null = null;
            let smallestDiff = Infinity;
            for (const history of sortedHistories) {
                const historyTime = new Date(history.datetime).getTime();
                if (historyTime <= twentyFourHoursAgo) {
                    const diff = twentyFourHoursAgo - historyTime;
                    if (diff < smallestDiff) {
                        smallestDiff = diff;
                        price24hAgo = history.price;
                    } else {
                        break; 
                    }
                }
            }
            if (price24hAgo === null) {
                price24hAgo = priceNow;
            }
            const change = (price24hAgo === 0) ? 0 : ((priceNow - price24hAgo) / price24hAgo) * 100;
            priceDataMap.set(currency.symbol.toUpperCase(), { now: priceNow, twentyFourHoursAgoPrice: price24hAgo, change: change });
            if (change > bestPerformer.change) {
                bestPerformer = { symbol: currency.symbol, change: change };
            }
        }
        
        // ... (cálculo dos balanços) ...
        let totalBalanceNow = 0;
        let totalBalance24hAgo = 0;
        for (const wallet of wallets) {
            const prices = wallet.currencySymbol ? priceDataMap.get(wallet.currencySymbol.toUpperCase()) : undefined;
            const balance = Number(wallet.balance);
            if (prices && !isNaN(balance)) {
                totalBalanceNow += balance * prices.now;
                totalBalance24hAgo += balance * (prices.twentyFourHoursAgoPrice ?? prices.now);
            }
        }
        const profitBRL = totalBalanceNow - totalBalance24hAgo;
        const profitPercent = (totalBalance24hAgo === 0 || totalBalanceNow === 0) ? 0 : (profitBRL / totalBalance24hAgo) * 100;

        return { totalBalanceBRL: totalBalanceNow, profitBRL, profitPercent, bestPerformer };
    }, [wallets, currencies]);

    // Montar os dados (mantido)
    const statsData = [
        {
            title: 'Balanço Total (BRL)',
            value: formatCurrencyValue(calculatedStats.totalBalanceBRL), // Usará a nova formatação
            Icon: Wallet,
            change: undefined,
        },
        {
            title: 'Lucro/Prejuízo (24h)',
            value: formatCurrencyValue(calculatedStats.profitBRL), // Usará a nova formatação
            change: formatPercentValue(calculatedStats.profitPercent),
            Icon: (calculatedStats.profitBRL ?? 0) >= 0 ? TrendingUp : TrendingDown,
        },
        {
            title: 'Melhor Ativo (24h)',
            value: calculatedStats.bestPerformer.symbol,
            change: formatPercentValue(calculatedStats.bestPerformer.change),
            Icon: TrendingUp,
        },
        {
            title: 'Total de Carteiras',
            value: wallets.length.toString(),
            Icon: Award,
            change: undefined,
        },
    ];

    // Renderização (mantida)
    return (
        <Box
            component={motion.div}
            variants={containerVariants}
            initial="hidden"
            animate="visible"
            sx={{ mb: 4 }}
        >
            <Grid container spacing={3}>
                {statsData.map((stat, index) => (
                    <Grid item xs={12} sm={6} md={3} key={index}>
                        <motion.div variants={itemVariants}>
                            <StatCard 
                                title={stat.title}
                                value={stat.value}
                                Icon={stat.Icon}
                                {...(stat.change !== undefined && { change: stat.change })}
                            />
                        </motion.div>
                    </Grid>
                ))}
            </Grid>
        </Box>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\SwapWidget.tsx ====
'use client';
import React, { useState, useMemo } from 'react';
import { CircularProgress, MenuItem, Select, Typography } from '@mui/material';
import { ArrowDownUp, Wallet, CheckCircle2, AlertCircle } from 'lucide-react';
import { useDashboardWallets, useDashboardCurrencies, useDashboardActions } from '../store/DashboardStore';
import { useAuthUser } from '@/features/auth/store/useAuthStore';
import { useNotification } from '@/shared/context/NotificationContext';
import walletService, { TradeRequestDTO } from '@/features/wallet/services/walletService';

export const SwapWidget = () => {
    const { showNotification } = useNotification();
    const { fetchDashboardData } = useDashboardActions();
    const wallets = useDashboardWallets();
    const currencies = useDashboardCurrencies();
    const user = useAuthUser();
    
    const [fromWalletId, setFromWalletId] = useState<number | string>('');
    const [toCurrencySymbol, setToCurrencySymbol] = useState<string>('');
    const [amountToSpend, setAmountToSpend] = useState<string>('');
    const [isLoading, setIsLoading] = useState(false);

    // Filtros
    const spendableWallets = useMemo(() => wallets.filter(w => Number(w.balance) > 0), [wallets]);
    
    const selectedWallet = useMemo(() => 
        wallets.find(w => w.id === Number(fromWalletId)), 
    [fromWalletId, wallets]);

    const receivableCurrencies = useMemo(() => {
        if (!selectedWallet) return currencies;
        return currencies.filter(c => c.symbol !== selectedWallet.currencySymbol);
    }, [currencies, selectedWallet]);

    // Handler de submit
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!user.id || !selectedWallet || !toCurrencySymbol || !amountToSpend) return;

        setIsLoading(true);
        const tradeRequest: TradeRequestDTO = {
            userId: user.id,
            fromWalletId: selectedWallet.id,
            toCurrencySymbol: toCurrencySymbol,
            amountToSpend: Number(amountToSpend),
        };

        try {
            await walletService.trade(tradeRequest);
            showNotification("Trade realizado com sucesso!", "success");
            fetchDashboardData();
            setAmountToSpend(''); // Limpa apenas o valor
        } catch (error: any) {
            const errorMsg = error.response?.data?.message || "Erro no trade.";
            showNotification(errorMsg, "error");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit} className="relative">
            <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-white flex items-center gap-2">
                    <span className="w-1.5 h-6 bg-yellow-500 rounded-full"></span>
                    Troca Rápida
                </h3>
                <span className="text-xs text-gray-500 font-mono bg-white/5 px-2 py-1 rounded">Taxa: 0%</span>
            </div>

            {/* CARD DE ORIGEM (VENDER) */}
            <div className="bg-[#0b0f19] border border-white/10 rounded-2xl p-4 mb-2 hover:border-yellow-500/30 transition-colors">
                <div className="flex justify-between text-xs text-gray-400 mb-2 font-medium uppercase tracking-wide">
                    <span>Vender</span>
                    <span className="flex items-center gap-1">
                        <Wallet size={12} /> 
                        Saldo: {selectedWallet ? Number(selectedWallet.balance).toFixed(4) : '0.00'}
                    </span>
                </div>
                
                <div className="flex items-center justify-between gap-4">
                    <input 
                        type="number"
                        placeholder="0.00"
                        value={amountToSpend}
                        onChange={(e) => setAmountToSpend(e.target.value)}
                        className="bg-transparent text-3xl font-bold text-white placeholder-gray-700 w-full focus:outline-none font-mono"
                        min="0"
                        step="any"
                        disabled={isLoading || !fromWalletId}
                    />
                    
                    {/* Select Customizado (Simplificado com MUI mas estilizado) */}
                    <Select
                        value={fromWalletId}
                        onChange={(e) => setFromWalletId(e.target.value)}
                        displayEmpty
                        variant="standard"
                        disableUnderline
                        sx={{
                            color: 'white',
                            fontWeight: 'bold',
                            bgcolor: '#1E293B',
                            borderRadius: '12px',
                            px: 2, py: 0.5,
                            '.MuiSelect-icon': { color: 'white' },
                            minWidth: '110px'
                        }}
                    >
                        <MenuItem value="" disabled>Carteira</MenuItem>
                        {spendableWallets.map(w => (
                            <MenuItem key={w.id} value={w.id}>{w.currencySymbol}</MenuItem>
                        ))}
                    </Select>
                </div>
            </div>

            {/* DIVISOR / BOTÃO INVERTER */}
            <div className="absolute left-1/2 top-[48%] -translate-x-1/2 -translate-y-1/2 z-10">
                <div className="bg-[#1E293B] p-2 rounded-xl border-4 border-[#0f172a] text-yellow-500">
                    <ArrowDownUp size={20} />
                </div>
            </div>

            {/* CARD DE DESTINO (RECEBER) */}
            <div className="bg-[#0b0f19] border border-white/10 rounded-2xl p-4 mt-2 mb-6 hover:border-yellow-500/30 transition-colors">
                <div className="flex justify-between text-xs text-gray-400 mb-2 font-medium uppercase tracking-wide">
                    <span>Receber (Estimado)</span>
                </div>
                
                <div className="flex items-center justify-between gap-4">
                    <div className="text-3xl font-bold text-gray-500 font-mono">
                        {/* Aqui poderia vir o cálculo estimado se tivéssemos o preço live no front */}
                        ---
                    </div>

                    <Select
                        value={toCurrencySymbol}
                        onChange={(e) => setToCurrencySymbol(e.target.value)}
                        displayEmpty
                        variant="standard"
                        disableUnderline
                        sx={{
                            color: 'white',
                            fontWeight: 'bold',
                            bgcolor: '#1E293B',
                            borderRadius: '12px',
                            px: 2, py: 0.5,
                            '.MuiSelect-icon': { color: 'white' },
                            minWidth: '110px'
                        }}
                    >
                        <MenuItem value="" disabled>Moeda</MenuItem>
                        {receivableCurrencies.map(c => (
                            <MenuItem key={c.id || c.symbol} value={c.symbol}>{c.symbol}</MenuItem>
                        ))}
                    </Select>
                </div>
            </div>

            <button
                type="submit"
                disabled={isLoading || !fromWalletId || !toCurrencySymbol || !amountToSpend}
                className="w-full py-4 rounded-xl bg-yellow-500 hover:bg-yellow-400 text-black font-bold text-lg shadow-[0_0_20px_rgba(240,185,11,0.3)] hover:shadow-[0_0_30px_rgba(240,185,11,0.5)] transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none flex items-center justify-center gap-2"
            >
                {isLoading ? <CircularProgress size={24} color="inherit" /> : 'Confirmar Troca'}
            </button>
        </form>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\WalletCard.tsx ====
'use client';
import { Box, Typography, Button, Stack } from '@mui/material';
import { Wallet } from '@/features/wallet/services/walletService';
import { ArrowDownLeft, ArrowUpRight } from 'lucide-react';
import CoinIcon from '@/features/currency/components/CoinIcon'; // Importação do novo componente

// Função de formatação de valores grandes
const formatCurrencyValue = (value: number | undefined | null): string => {
    const numericValue = Number(value);
    if (isNaN(numericValue) || value === undefined || value === null) return "R$ --";
    
    // Se for pequeno, mostra com precisão
    if (numericValue < 1000 && numericValue > -1000) {
        return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2 });
    }
    
    // Abreviações para valores grandes
    const prefix = "R$ ";
    if (numericValue >= 1_000_000_000_000) return prefix + (numericValue / 1_000_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) + " T";
    if (numericValue >= 1_000_000_000) return prefix + (numericValue / 1_000_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) + " B";
    if (numericValue >= 1_000_000) return prefix + (numericValue / 1_000_000).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) + " M";
    
    return numericValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
};

interface WalletCardProps {
    wallet: Wallet;
    currencySymbol?: string;
    valueBRL: number | undefined;
    onDepositClick: () => void;
}

export const WalletCard = ({ wallet, currencySymbol, valueBRL, onDepositClick }: WalletCardProps) => {
    const displayValueBRL = valueBRL;
    const displayAmount = Number(wallet.balance);
    const displayName = wallet.name;
    // Habilita ações apenas para Spot e Funding
    const showActions = wallet.category === 'Spot' || wallet.category === 'Funding';

    return (
        <div className="glass-panel p-5 rounded-2xl relative group hover:bg-white/5 transition-all duration-300 border border-white/5 hover:border-yellow-500/20">
            {/* Topo do Card */}
            <div className="flex justify-between items-start mb-4">
                <div className="flex items-center gap-3">
                    {/* NOVO ÍCONE DINÂMICO */}
                    <div className="w-10 h-10 flex items-center justify-center filter drop-shadow-lg">
                        <CoinIcon symbol={currencySymbol || '?'} name={displayName} size={40} />
                    </div>
                    
                    <div>
                        <h4 className="font-bold text-white leading-tight">{displayName}</h4>
                        <span className="text-[10px] font-bold text-gray-500 uppercase tracking-widest bg-black/30 px-1.5 py-0.5 rounded">
                            {wallet.category}
                        </span>
                    </div>
                </div>

                {/* Quantidade (Se não for BRL) */}
                {currencySymbol !== 'BRL' && (
                    <div className="text-right">
                        <p className="text-[10px] text-gray-500 font-mono uppercase tracking-wider">Saldo</p>
                        <p className="text-sm font-mono text-gray-300 font-medium">
                            {displayAmount.toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 8 })} <span className="text-xs text-yellow-500/80">{currencySymbol}</span>
                        </p>
                    </div>
                )}
            </div>

            {/* Valor Principal em BRL */}
            <div className="mb-6">
                <p className="text-2xl font-bold text-white tracking-tight font-mono">
                    {formatCurrencyValue(displayValueBRL)}
                </p>
            </div>

            {/* Botões de Ação (Aparecem suaves) */}
            {showActions && (
                <div className="grid grid-cols-2 gap-3">
                    <button
                        onClick={onDepositClick}
                        disabled={wallet.currencySymbol !== 'BRL'}
                        className={`flex items-center justify-center gap-2 py-2.5 rounded-xl text-xs font-bold uppercase tracking-wide transition-all
                            ${wallet.currencySymbol === 'BRL' 
                                ? 'bg-yellow-500 hover:bg-yellow-400 text-black shadow-lg shadow-yellow-500/20' 
                                : 'bg-white/5 text-gray-500 cursor-not-allowed opacity-50'}`}
                        title={wallet.currencySymbol !== 'BRL' ? "Depósito direto apenas em BRL (Use Trade para cripto)" : "Depositar BRL"}
                    >
                        <ArrowDownLeft size={16} /> Depositar
                    </button>
                    
                    <button 
                        disabled 
                        className="flex items-center justify-center gap-2 py-2.5 rounded-xl text-xs font-bold uppercase tracking-wide bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white transition-all cursor-not-allowed opacity-70"
                    >
                        <ArrowUpRight size={16} /> Sacar
                    </button>
                </div>
            )}
        </div>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\components\WalletGrid.tsx ====
// Caminho: frontend/src/features/dashboard/components/WalletGrid.tsx
'use client';
import { Grid, Typography, Box } from '@mui/material';
// 1. RE-ADICIONAR useDashboardCurrencies
import { useDashboardWallets, useDashboardCurrencies } from '../store/DashboardStore'; 
import { WalletCard } from './WalletCard';
import { useState, useMemo } from 'react'; // Adicionar useMemo
import { Wallet } from '@/features/wallet/services/walletService';
// 2. Importar o DepositModal (que já estava)
import DepositModal from '@/features/wallet/components/DepositModal';

export const WalletGrid = () => {
    const wallets = useDashboardWallets();
    // 3. BUSCAR CURRENCIES NOVAMENTE
    const currencies = useDashboardCurrencies(); 

    // 4. ADICIONAR O MAPA DE PREÇOS (Copiado de StatsCards)
    const currentPrices = useMemo(() => {
        return currencies.reduce((map, currency) => {
            if (currency.histories && currency.histories.length > 0 && currency.symbol) {
                // Ordena para garantir o preço mais recente
                const latestHistory = [...currency.histories].sort((a, b) => new Date(b.datetime).getTime() - new Date(a.datetime).getTime())[0];
                if (latestHistory) {
                    map[currency.symbol.toUpperCase()] = latestHistory.price;
                }
            }
            return map;
        }, {} as Record<string, number>);
    }, [currencies]);

    // Lógica do modal (mantida)
    const [depositModalOpen, setDepositModalOpen] = useState(false);
    const [selectedWallet, setSelectedWallet] = useState<Wallet | null>(null);
    const handleOpenDepositModal = (wallet: Wallet) => {
        setSelectedWallet(wallet);
        setDepositModalOpen(true);
    };
    const handleCloseModals = () => {
        setSelectedWallet(null);
        setDepositModalOpen(false);
    };

    if (!wallets || wallets.length === 0) {
        return (
            <Box sx={{ mt: 4, p: 3, bgcolor: '#1E1E1E', borderRadius: 4, textAlign: 'center' }}>
                <Typography variant="h6" fontWeight="bold" sx={{ mb: 1 }}>Suas Carteiras</Typography>
                <Typography color="text.secondary">Nenhuma carteira encontrada.</Typography>
            </Box>
        );
    }

    return (
        <>
            <Typography variant="h6" fontWeight="bold" sx={{ mt: 4, mb: 2 }}>
                Suas Carteiras ({wallets.length})
            </Typography>
            <Grid container spacing={3}>
                {wallets.map(wallet => {
                    // 5. CALCULAR O VALOR BRL AQUI
                    const balanceAsNumber = Number(wallet.balance);
                    
                    // Trata BRL como preço 1.0, senão busca no mapa
                    const price = (wallet.currencySymbol === 'BRL') 
                        ? 1.0 
                        : (wallet.currencySymbol ? currentPrices[wallet.currencySymbol.toUpperCase()] : undefined);

                    const valueBRL = (price !== undefined && !isNaN(balanceAsNumber)) 
                        ? (balanceAsNumber * price) 
                        : undefined; // Passa undefined se o preço não for encontrado

                    return (
                         <Grid item xs={12} sm={6} md={3} key={wallet.id}>
                            <WalletCard 
                                wallet={wallet} 
                                currencySymbol={wallet.currencySymbol}
                                valueBRL={valueBRL} // <-- 6. PASSAR O VALOR CALCULADO
                                onDepositClick={() => handleOpenDepositModal(wallet)}
                            />
                        </Grid>
                    );
                })}
            </Grid>

            {/* Modal de Depósito */}
            <DepositModal
                open={depositModalOpen}
                onClose={handleCloseModals}
                wallet={selectedWallet}
            />
        </>
    );
};

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\pages\DashboardPage.tsx ====
'use client';

import React, { useEffect, useState } from 'react';
import { Box, CircularProgress, Container, Grid, Button } from '@mui/material';
import { useAuthUser } from '@/features/auth/store/useAuthStore';
import { Plus, Calendar, Clock } from 'lucide-react'; // Ícones novos

// Imports da Arquitetura
import { useDashboardLoading, useDashboardError, useDashboardActions } from '@/features/dashboard/store/DashboardStore';
import { StatsCards } from '@/features/dashboard/components/StatsCards';
import { OverviewChart } from '@/features/dashboard/components/OverviewChart';
import { HotList } from '@/features/dashboard/components/HotList';
import { WalletGrid } from '@/features/dashboard/components/WalletGrid';
import { SwapWidget } from '@/features/dashboard/components/SwapWidget';
import CreateWalletModal from '@/features/wallet/components/CreateWalletModal';
import TransactionsTable from '@/features/wallet/components/TransactionsTable';
import walletService, { WalletTransaction } from '@/features/wallet/services/walletService';

export default function DashboardPage() {
    const user = useAuthUser();
    const loading = useDashboardLoading();
    const error = useDashboardError();
    const { fetchDashboardData } = useDashboardActions();
    
    const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
    const [transactions, setTransactions] = useState<WalletTransaction[]>([]);
    
    // Estado para data/hora
    const [currentDate, setCurrentDate] = useState<string>("");
    const [currentTime, setCurrentTime] = useState<string>("");

    // Atualiza relógio
    useEffect(() => {
        const updateTime = () => {
            const now = new Date();
            setCurrentDate(now.toLocaleDateString('pt-BR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }));
            setCurrentTime(now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }));
        };
        updateTime();
        const timer = setInterval(updateTime, 60000); // Atualiza a cada minuto
        return () => clearInterval(timer);
    }, []);

    useEffect(() => {
        fetchDashboardData();
    }, [fetchDashboardData]);

    useEffect(() => {
        const loadHistory = async () => {
            if (user.id) {
                try {
                    const data = await walletService.getHistory(user.id);
                    setTransactions(data);
                } catch (e) {
                    console.error("Erro histórico:", e);
                }
            }
        };
        if (!loading) loadHistory();
    }, [user.id, loading]); 

    if (error) {
       return (
         <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh', flexDirection: 'column' }}>
            <span className="text-red-500 font-bold text-lg mb-2">Erro de Conexão</span>
            <span className="text-gray-400">{error}</span>
         </Box>
      );
    }

    if (loading) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
          <div className="flex flex-col items-center gap-4">
             <CircularProgress sx={{ color: '#F0B90B' }} />
             <span className="text-yellow-500 font-mono text-sm animate-pulse">SINCRONIZANDO BLOCKCHAIN...</span>
          </div>
        </Box>
      );
    }

   return (
        // Mudamos de "2xl" para "xl"
        <Container maxWidth="xl" sx={{ p: 0 }}>
            {/* Header da Página - Estilo "Welcome" */}
            <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 gap-4">
                <div>
                    <h1 className="text-3xl font-bold text-white mb-1">
                        Olá, <span className="text-yellow-500">{user.name?.split(' ')[0]}</span> ??
                    </h1>
                    <div className="flex items-center gap-4 text-gray-400 text-sm font-medium">
                        <div className="flex items-center gap-1.5">
                            <Calendar size={14} className="text-yellow-500" />
                            <span className="capitalize">{currentDate}</span>
                        </div>
                        <div className="hidden md:block h-1 w-1 rounded-full bg-gray-600"></div>
                        <div className="flex items-center gap-1.5">
                            <Clock size={14} className="text-yellow-500" />
                            <span>{currentTime}</span>
                        </div>
                    </div>
                </div>

                <button
                    onClick={() => setIsCreateModalOpen(true)}
                    className="flex items-center gap-2 bg-yellow-500 hover:bg-yellow-400 text-black px-5 py-2.5 rounded-xl font-bold transition-all shadow-[0_0_15px_rgba(240,185,11,0.3)] hover:shadow-[0_0_25px_rgba(240,185,11,0.5)] active:scale-95"
                >
                    <Plus size={20} strokeWidth={3} />
                    Nova Carteira
                </button>
            </div>

            {/* Cards de Estatísticas */}
            <div className="mb-8">
                <StatsCards />
            </div>

            {/* Grid Principal */}
            <Grid container spacing={4}>
                {/* Coluna Principal (Esquerda) */}
                <Grid item xs={12} xl={8}>
                    <div className="space-y-8">
                        {/* Gráfico */}
                        <div className="glass-panel p-1 rounded-3xl overflow-hidden">
                            <OverviewChart />
                        </div>
                        
                        {/* Carteiras */}
                        <div>
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                    <span className="w-1.5 h-6 bg-yellow-500 rounded-full"></span>
                                    Ativos em Carteira
                                </h3>
                            </div>
                            <WalletGrid />
                        </div>

                        {/* Histórico */}
                        <TransactionsTable transactions={transactions} />
                    </div>
                </Grid>

                {/* Coluna Lateral (Direita) */}
                <Grid item xs={12} xl={4}>
                    <div className="space-y-8 sticky top-6">
                        {/* Swap Widget */}
                        <div className="glass-panel p-6 rounded-3xl border border-yellow-500/20 shadow-[0_0_30px_rgba(240,185,11,0.05)] relative overflow-hidden">
                            <div className="absolute top-0 right-0 w-32 h-32 bg-yellow-500/10 rounded-full blur-3xl -translate-y-1/2 translate-x-1/2"></div>
                            <SwapWidget />
                        </div>

                        {/* Hot List */}
                        <div className="glass-panel p-6 rounded-3xl">
                            <h3 className="text-lg font-bold text-white mb-4 flex items-center gap-2">
                                ?? Tendências de Mercado
                            </h3>
                            <HotList />
                        </div>
                    </div>
                </Grid>
            </Grid>

            <CreateWalletModal
                open={isCreateModalOpen}
                onClose={() => setIsCreateModalOpen(false)}
            />
        </Container>
    );
}

---- end of file ----

==== C:\dev\AMS_HoldCrypto\frontend\src\features\dashboard\store\DashboardStore.ts ====
// Caminho: frontend/src/features/dashboard/store/DashboardStore.ts

import { create } from 'zustand';
import { Currency } from '@/features/currency/types/Currency';
import currencyService from '@/features/currency/services/currencyService';
import walletService, { Wallet } from '@/features/wallet/services/walletService'; // Ajuste o caminho se necessário
import { useAuthStore } from '@/features/auth/store/useAuthStore'; // Ajuste o caminho se necessário

interface DashboardState {
  currencies: Currency[];
  wallets: Wallet[];
  selectedCoin: Currency | null;
  loading: boolean;
  error: string | null;
  fetchDashboardData: () => Promise<void>;
  setSelectedCoin: (coin: Currency | null) => void;
  // Adicionado 'actions' ao estado para seleção estável
  actions: {
      fetchDashboardData: () => Promise<void>;
      setSelectedCoin: (coin: Currency | null) => void;
  };
}

const initialState = {
  currencies: [],
  wallets: [],
  selectedCoin: null,
  loading: true,
  error: null,
};

export const useDashboardStore = create<DashboardState>((set, get) => ({
  ...initialState,
  fetchDashboardData: async () => {
    const { isAuthenticated, user } = useAuthStore.getState();
    const userId = user.id;

    if (!isAuthenticated || !userId) {
      console.warn("DashboardStore: User not authenticated or userId not available. Skipping data fetch.");
      // Limpa dados e para o loading, define erro
      set({ ...initialState, loading: false, error: "Usuário não autenticado." });
      return;
    }

    console.log(`DashboardStore: Fetching data for userId: ${userId}`);
    set({ loading: true, error: null });

    try {
      const [currencyData, walletData] = await Promise.all([
        currencyService.getAll(),
        walletService.getUserWallets(userId)
      ]);

      console.log("DashboardStore: Currencies fetched:", currencyData);
      console.log("DashboardStore: Wallets fetched:", walletData);

      set({
        currencies: currencyData,
        wallets: walletData,
        selectedCoin: currencyData.length > 0 ? currencyData[0] : null,
        loading: false,
        error: null,
      });
      console.log("DashboardStore: State updated successfully.");

    } catch (error: any) {
      console.error("DashboardStore: Error fetching data:", error);
      const errorMessage = error.response?.data?.message || "Falha ao carregar dados do dashboard.";
      set({
        ...initialState, // Reseta dados em caso de erro
        loading: false,
        error: errorMessage
       });
    }
  },

  setSelectedCoin: (coin) => {
    set({ selectedCoin: coin });
  },

  // Popula o objeto 'actions' com as funções definidas acima
  // Isso garante que a referência ao objeto 'actions' seja estável
  actions: {
      fetchDashboardData: () => get().fetchDashboardData(),
      setSelectedCoin: (coin) => get().setSelectedCoin(coin),
  }
}));

// Hooks de conveniência
export const useDashboardCurrencies = () => useDashboardStore((state) => state.currencies);
export const useDashboardWallets = () => useDashboardStore((state) => state.wallets);
export const useDashboardSelectedCoin = () => useDashboardStore((state) => state.selectedCoin);
export const useDashboardLoading = () => useDashboardStore((state) => state.loading);
export const useDashboardError = () => useDashboardStore((state) => state.error);

// Hook de ações corrigido para selecionar o objeto 'actions' estável
export const useDashboardActions = () => useDashboardStore((state) => state.actions);

---- end of file ----

